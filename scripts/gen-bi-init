#!/usr/bin/env python

# create the LBuiltin register calls for the described builtins

import re
import sys
import jpylib as y

print("""\
// initialise the builtin functions -- generated; DO NOT EDIT HERE!!

package org.w21.lyk

// a few emptynesses predeclared for convenience
val noStd = arrayOf<String>()                  // no standard parameters
val noKey = mapOf<String, LObject>()           // no &key parameters
val noOpt = arrayOf<Pair<String, LObject>>()   // no &optional parameters
val noRest = null                              // no &rest parameter
val noRet = "nil"                              // no return value


// initialise all builtin functions
fun init_Builtins() {

""")

builtin = None                          # keyword => value, also, in one?
in_doc = False                          # in a docstring, if true
docstring = None                        # the collected docstring
filename = None                         # filename, for defined-in and errors
lineno = 0                              # line#, for defined-in and errors


def prin(*args, **kwargs):
    """Print all arguments, without separator or line end."""
    print(*args, sep="", end="", **kwargs)


def print_init(builtin):
    """Print the initialisation call of the builtin function."""
    errors = False
    for key in builtin:
        if builtin.get(key) == None:
            err(f"builtin {builtin.name}: missing {key}")
            errors = True
    if errors:
        sys.exit(1)

    prin(f'    LBuiltin("{builtin.name}", ::{builtin.fun},\n            ')
    if builtin.std:
        prin("/* std */ ")
        content = "\", \"".join(builtin.std)
        prin(f'arrayOf<String>("{content}")')
    else:
        prin("noStd")
    prin(",\n            ")

    if builtin.key:
        prin("/* key */ ")
        prin("mapOf<String, LObject>(")
        prin(" ".join(builtin.key))
        prin(")")
    else:
        prin("noKey")
    prin(",\n            ")

    if builtin.opt:
        prin("/* opt */ ")
        prin("arrayOf<Pair<String, LObject>>(")
        for vardef in builtin.opt.split(","):
            parts = vardef.split()
            var = parts[0]
            if len(parts) == 1:
                value = "Nil"
            elif len(parts) == 2:
                value = parts[1]
            else:
                errx(f"botched opt in {builtin.name}")
            prin(f"Pair(\"{var}\", {value}), ")
        prin(")")
    else:
        prin("noOpt")
    prin(",\n            ")

    if builtin.rest:
        prin("/* rest */ ")
        prin('"', builtin.rest[0], '"')
    else:
       prin("noRest")
    prin(",\n            ")
    if builtin.ret:
        prin("/* ret */ ")
        prin('"', builtin.ret, '"')
    else:
        prin("noRet")
    prin(",\n            ")
    prin("/* special */ ")
    prin(repr(y.boolish(builtin.special[0])).lower())
    prin(",\n            ")
    print('"""\n' + builtin.doc + '""",')
    print(f'            "{filename}:{lineno}:1")')
    print()


def errx(message):
    """Exit with an error message that can be parsed by Emacs."""
    sys.exit(f"\n{filename}:{lineno}: " + message)

def err(message):
    """Print an error message that can be parsed by Emacs."""
    print("\n{filename}:{lineno}: " + message, file=sys.stderr)

wrap_column = 76                          # wrap the infotainment output here
column = 0                                # keep track of column for line wrap

def notef(s):
    """Print a notice for infotainment; wrap at wrap_column."""
    global column
    if y.is_notice():
        if len(s) + column > wrap_column:
            print(file=sys.stderr)
            column = 0
        print(s, file=sys.stderr, end="", flush=True)
        column += len(s)

    
def all_lines(files):
    """Return lines from all input files with builtin function information."""
    global filename
    global lineno
    for file in files:
        with open(file) as f:
            filename = file
            lineno = 0
            for line in f:
                lineno += 1
                if line.startswith("/// "):
                    yield re.sub("^/// ?", "", line)
                

ovc, args = y.pgetopts({
    "q": ("quiet", y.alert_level_zero, y.alert_level(y.L_NOTICE),
          "be quiet (no output except error messages)"),
    "v": ("verbose", y.alert_level_up, y.alert_level(y.L_NOTICE),
          "increase verbosity (up to 3 make sense)"),
})

# Now go ahead and assemble the builtin function information.
try:
    notef("register builtins ")
    for line in all_lines(args):
        line = line.rstrip()
        y.debug("I read:", line)

        if in_doc:                        # assemble docstring
            if line.lstrip() == "}":
                builtin["doc"] = "\n".join(docstring)
                in_doc = False
            else:
                if builtin.name == "defun":
                    y.debug(f" >>{line}<<")
                docstring.append(line)
            continue

        if not line or line.startswith("#"):
            continue

        # split line into command and arguments
        parts = line.split()
        cmd = parts[0]

        if builtin:
            if cmd in ("std", "key", "rest"):
                y.info(f" builtin[{cmd}] = {parts[1:]}")
                builtin[cmd] = parts[1:]
            elif cmd in ("opt"):
                arg = " ".join(parts[1:])
                y.info(f" builtin[{cmd}] = {arg}")
                builtin[cmd] = arg
            elif cmd in ("fun", "ret", "special"):
                if len(parts) != 2:
                    y.debug(line)
                    errx(f"exactly one parameter needed for '{cmd}'")
                y.info(f" builtin[{cmd}] = {parts[1]}")
                builtin[cmd] = parts[1]
            elif cmd == "doc":
                if len(parts) != 2 or parts[1] != "{":
                    errx("missing opening brace after 'doc'")
                in_doc = True
                docstring = []
            elif cmd == "end":
                if len(parts) != 2 or parts[1] != "builtin":
                    errx("missing 'builtin' after 'end'")
                print_init(builtin)
                builtin = None            # end this, signal we are out of one
            else:
                errx(f"unexpected command '{cmd}'")
            continue

        if cmd == "builtin":              # prepare the data structure
            if len(parts) != 2:
                errx("builtin without name")
            builtin = y.Namespace(name=parts[1], fun=None, std=None, key=None,
                                  opt=None, rest=None, ret=None, doc=None,
                                  special=False)
            notef(f"{builtin.name}, ")
        else:
            errx(f"unexpected command '{cmd}', expected 'builtin <name>'")

    # end the builtin functions init file
    print("""\
}
// EOF
""")
    notef("\nbuiltins registered\n")
except FileNotFoundError as e:
    sys.exit(e)

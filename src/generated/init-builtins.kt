// DO NOT EDIT!! This file has been generated by scripts/generate-builtin-init
// at 2024-06-19T22:57:48 from the builtin function descriptions in
//     builtins/alists.kt
//     builtins/basic.kt
//     builtins/chars.kt
//     builtins/cxr.kt
//     builtins/environments.kt
//     builtins/factor.kt
//     builtins/files.kt
//     builtins/io.kt
//     builtins/macros.kt
//     builtins/numbers.kt
//     builtins/sequences.kt
//     builtins/strings.kt
//     builtins/system.kt
//     builtins/tables.kt
//     builtins/utils.kt
//     builtins/vectors.kt
//
// All builtin functions are registered here.

package org.w21.lyk

import kotlin.math.E


// a few emptynesses predeclared for convenience
val noStd = arrayOf<String>()                  // no standard parameters
val noKey = mapOf<String, LObject>()           // no &key parameters
val noOpt = arrayOf<Pair<String, LObject>>()   // no &optional parameters
val noRest = null                              // no &rest parameter


fun init_Builtins() {

    LBuiltin("assoc", ::bi_assoc,
            /* std */ arrayOf<String>("item", "alist"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "cons/nil",
            /* special */ false,
            """
Look up `item` in `alist` and return the pair whose car is equal to `item`.
Return nil if `item` is not found.""",
            "builtins/alists.kt:39:1")

    LBuiltin("sassoc", ::bi_sassoc,
            /* std */ arrayOf<String>("item", "alist", "default"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "cons/nil",
            /* special */ false,
            """
Look up `item` in `alist`; return the pair whose car is equal to `item`.
If `item` is not in `alist`, return `default`, or if it is a function,
call it with no args and return the result.""",
            "builtins/alists.kt:63:1")

    LBuiltin("assq", ::bi_assq,
            /* std */ arrayOf<String>("item", "alist"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "cons/nil",
            /* special */ false,
            """
Look up `item` in `alist` and return the pair whose car is eq to `item`.
Return nil if `item` is not found as a car in one of the pairs in `alist`.""",
            "builtins/alists.kt:93:1")

    LBuiltin("sassq", ::bi_sassq,
            /* std */ arrayOf<String>("item", "alist", "default"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "cons/nil",
            /* special */ false,
            """
Look up `item` in `alist`; return the pair whose car is eq to `item`.
If `item` is not in `alist`, return `default`, or if it is a function,
call it with no args and return the result.""",
            "builtins/alists.kt:117:1")

    LBuiltin("assoc-if", ::bi_assoc_if,
            /* std */ arrayOf<String>("predicate", "alist"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "cons/nil",
            /* special */ false,
            """
Return the first cons in `alist` for whose car `predicate` is true.
If there is no such cons, return nil.""",
            "builtins/alists.kt:147:1")

    LBuiltin("assoc-if-not", ::bi_assoc_if_not,
            /* std */ arrayOf<String>("predicate", "alist"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "cons/nil",
            /* special */ false,
            """
Return the first cons in `alist` for whose car `predicate` is false.
If there is no such cons, return nil.""",
            "builtins/alists.kt:171:1")

    LBuiltin("car", ::bi_car,
            /* std */ arrayOf<String>("list"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "object",
            /* special */ false,
            """
Return the contents of the address part of the `list` register.
The car of nil is nil.""",
            "builtins/basic.kt:19:1")

    LBuiltin("cdr", ::bi_cdr,
            /* std */ arrayOf<String>("list"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "object",
            /* special */ false,
            """
Return the contents of the decrement part of the `list` register.
The cdr of nil is nil.""",
            "builtins/basic.kt:38:1")

    LBuiltin("rplaca", ::bi_rplaca,
            /* std */ arrayOf<String>("cons", "new-car"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "cons",
            /* special */ false,
            """
Replace the car of `cons` with `new-car` and return `cons`.""",
            "builtins/basic.kt:56:1")

    LBuiltin("rplacd", ::bi_rplacd,
            /* std */ arrayOf<String>("cons", "new-cdr"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "cons",
            /* special */ false,
            """
Replace the cdr of `cons` with `new-cdr` and return `cons`.""",
            "builtins/basic.kt:76:1")

    LBuiltin("intern", ::bi_intern,
            /* std */ arrayOf<String>("name"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "symbol",
            /* special */ false,
            """
Return the (maybe new) interned symbol with the name `name` (a string).""",
            "builtins/basic.kt:96:1")

    LBuiltin("list", ::bi_list,
            noStd,
            noKey,
            noOpt,
            /* rest */ "elems",
            /* ret */ "list",
            /* special */ false,
            """
Return a list with the elements `elems`.""",
            "builtins/basic.kt:114:1")

    LBuiltin("list*", ::bi_list_star,
            noStd,
            noKey,
            noOpt,
            /* rest */ "elems+",
            /* ret */ "list",
            /* special */ false,
            """
Return a list of `elems`, with the last as the end of the list.
list* is like list except that the last argument to list becomes
the car of the last cons constructed, while the last argument to
list* becomes the cdr of the last cons constructed.""",
            "builtins/basic.kt:135:1")

    LBuiltin("cons", ::bi_cons,
            /* std */ arrayOf<String>("car", "cdr"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "cons",
            /* special */ false,
            """
Return a new cons consisting of `car` and `cdr`.""",
            "builtins/basic.kt:153:1")

    LBuiltin("set", ::bi_set,
            /* std */ arrayOf<String>("value", "symbol"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Assign `value` to the variable `symbol`; return the new value.""",
            "builtins/basic.kt:172:1")

    LBuiltin("quote", ::bi_quote,
            /* std */ arrayOf<String>("expr"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "expr",
            /* special */ true,
            """
Return the expression `expr` without evaluating it.""",
            "builtins/basic.kt:192:1")

    LBuiltin("setq", ::bi_setq,
            noStd,
            noKey,
            noOpt,
            /* rest */ "symbol-value-settings",
            /* ret */ "new-value",
            /* special */ true,
            """
Assign the value of `expr` to (un-evaluated) `symbol` and return the value.
Multiple settings like `(setq var1 form1 var2 form2 ...)` are possible.
First form1 is evaluated and the result is stored in the variable var1,
then form2 is evaluated and the result stored in var2, and so forth.""",
            "builtins/basic.kt:213:1")

    LBuiltin("let", ::bi_let,
            /* std */ arrayOf<String>("bindings"),
            noKey,
            noOpt,
            /* rest */ "bodyforms",
            /* ret */ "value",
            /* special */ true,
            """
Evaluate bodyforms with local bindings, return value of last bodyform.
Bindings are of the form `symbol` or `(symbol)` or `(symbol value)`,
where the first two bind `symbol` to nil. All `value`s are evaluated
before any variable bindings are done.""",
            "builtins/basic.kt:346:1")

    LBuiltin("let*", ::bi_letrec,
            /* std */ arrayOf<String>("bindings"),
            noKey,
            noOpt,
            /* rest */ "bodyforms",
            /* ret */ "value",
            /* special */ true,
            """
Evaluate bodyforms with local bindings, return value of last bodyform.
Bindings are of the form `symbol` or `(symbol)` or `(symbol value)`,
where the first two bind `symbol` to nil. VALUE is evaluated with
bindings of earlier variables in the same let* already in place.""",
            "builtins/basic.kt:367:1")

    LBuiltin("and", ::bi_and,
            noStd,
            noKey,
            noOpt,
            /* rest */ "args",
            /* ret */ "value",
            /* special */ true,
            """
Evaluate `args` until one is nil; return the last evaluated value.""",
            "builtins/basic.kt:386:1")

    LBuiltin("or", ::bi_or,
            noStd,
            noKey,
            noOpt,
            /* rest */ "args",
            /* ret */ "value",
            /* special */ true,
            """
Evaluate `args` until one is non-nil; return the last evaluated value.""",
            "builtins/basic.kt:411:1")

    LBuiltin("cond", ::bi_cond,
            noStd,
            noKey,
            noOpt,
            /* rest */ "clauses",
            /* ret */ "value",
            /* special */ true,
            """
For each clause of the form (condition expressions...) evaluate condition.
For the first one that is non-nil, return the last value of evaluating the
expressions. If none of the conditions is non-nil, return nil.""",
            "builtins/basic.kt:440:1")

    LBuiltin("progn", ::bi_progn,
            noStd,
            noKey,
            noOpt,
            /* rest */ "bodyforms",
            /* ret */ "last-value",
            /* special */ true,
            """
Evaluate all `bodyforms` and return the value of the last one.""",
            "builtins/basic.kt:471:1")

    LBuiltin("prog1", ::bi_prog1,
            /* std */ arrayOf<String>("result-form"),
            noKey,
            noOpt,
            /* rest */ "bodyforms",
            /* ret */ "first-value",
            /* special */ true,
            """
Evaluate all forms and return the value of the first one.""",
            "builtins/basic.kt:489:1")

    LBuiltin("lambda", ::bi_lambda,
            /* std */ arrayOf<String>("lambda-list"),
            noKey,
            noOpt,
            /* rest */ "bodyforms",
            /* ret */ "function",
            /* special */ true,
            """
Return an anonymous function with `lambda-list` and `bodyforms`.""",
            "builtins/basic.kt:511:1")

    LBuiltin("defun", ::bi_defun,
            /* std */ arrayOf<String>("name", "lambda-list"),
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("docstring", Nil), ),
            /* rest */ "bodyforms",
            /* ret */ "name",
            /* special */ true,
            """
Create a function with name `name`, `lambda-list`, and `bodyforms`.
Optional `docstring` should describe what the function does.
Return the function symbol `name`.
On calling the function, `bodyforms` will be evaluated in an environment
with the parameters bound to the actual arguments. The value of the last
form evaluated will be returned.""",
            "builtins/basic.kt:537:1")

    LBuiltin("null", ::bi_null,
            /* std */ arrayOf<String>("expr"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t if `expr` is nil, else nil.""",
            "builtins/basic.kt:566:1")

    LBuiltin("not", ::bi_null,
            /* std */ arrayOf<String>("expr"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t if `expr` is nil, else nil.""",
            "builtins/basic.kt:578:1")

    LBuiltin("eq", ::bi_eq,
            /* std */ arrayOf<String>("arg1", "arg2"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return t if arguments have the same atomic value or are the same object.
Strings and numbers are atomic, and equal strings/numbers are also eq.""",
            "builtins/basic.kt:597:1")

    LBuiltin("function", ::bi_function,
            /* std */ arrayOf<String>("arg"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "function",
            /* special */ true,
            """
Return the function value of a symbol, or the argument if it is a function.""",
            "builtins/basic.kt:617:1")

    LBuiltin("symbol-function", ::bi_symbol_function,
            /* std */ arrayOf<String>("symbol"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "symbol",
            /* special */ false,
            """
Return the function bound to `symbol`.
It is an error if there is no function bound to `symbol`.""",
            "builtins/basic.kt:650:1")

    LBuiltin("error", ::bi_error,
            /* std */ arrayOf<String>("message-format"),
            noKey,
            noOpt,
            /* rest */ "format-args",
            /* ret */ "no-return",
            /* special */ false,
            """
Raise error with `message-format` and optional `format-args`.
The error exits all active calls immediately, except for errset.
For the error message, the `format-args` will be formatted using
`message-format` as a format string.""",
            "builtins/basic.kt:676:1")

    LBuiltin("warning", ::bi_warning,
            /* std */ arrayOf<String>("message-format"),
            noKey,
            noOpt,
            /* rest */ "format-args",
            /* ret */ "nil",
            /* special */ false,
            """
Raise a warning with `message-format` and optional `format-args`.
If warnings are treated as errors (i.e. *warnings-as-errors* is true),
the warning exits all active calls immediately, except for errset.
Otherwise, only the message is printed as a warning, formatted as
specified.
For the warning message, the `format-args` will be formatted using
`message-format` as a format string.""",
            "builtins/basic.kt:703:1")

    LBuiltin("catch", ::bi_catch,
            /* std */ arrayOf<String>("tag"),
            noKey,
            noOpt,
            /* rest */ "bodyforms",
            /* ret */ "value",
            /* special */ true,
            """
Eval `bodyforms` as implicit progn. If a throw occurs to the `tag`,
which is evaluated, return the value that is thrown. Otherwise, return
the value of the last bodyform.""",
            "builtins/basic.kt:727:1")

    LBuiltin("throw", ::bi_throw,
            /* std */ arrayOf<String>("tag", "value"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "no-return",
            /* special */ false,
            """
Cause a non-local control transfer to the nearest enclosing catch
whose tag is eq to `tag`. The value returned by that catch is `value`.""",
            "builtins/basic.kt:770:1")

    LBuiltin("boundp", ::bi_boundp,
            /* std */ arrayOf<String>("symbol"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t if a value is bound to `symbol`, nil otherwise.""",
            "builtins/basic.kt:792:1")

    LBuiltin("fboundp", ::bi_fboundp,
            /* std */ arrayOf<String>("symbol"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t if a function is bound to `symbol`, nil otherwise.""",
            "builtins/basic.kt:811:1")

    LBuiltin("errset", ::bi_errset,
            /* std */ arrayOf<String>("expr"),
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("print-error", T), ),
            noRest,
            /* ret */ "result",
            /* special */ true,
            """
Return the value of `expr` as a singleton list; on error return nil.
In the latter case, a description of the error is in *last-error*, and,
if optional `print-error` is non-nil or omitted, it is printed as well.""",
            "builtins/basic.kt:835:1")

    LBuiltin("makunbound", ::bi_makunbound,
            /* std */ arrayOf<String>("symbol"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "symbol",
            /* special */ false,
            """
Make `symbol`s value be undefined, return `symbol`.""",
            "builtins/basic.kt:867:1")

    LBuiltin("fmakunbound", ::bi_fmakunbound,
            /* std */ arrayOf<String>("symbol"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "symbol",
            /* special */ false,
            """
Make `symbol`s function be undefined, return `symbol`.""",
            "builtins/basic.kt:887:1")

    LBuiltin("funcall", ::bi_funcall,
            /* std */ arrayOf<String>("function"),
            noKey,
            noOpt,
            /* rest */ "arguments",
            /* ret */ "value",
            /* special */ false,
            """
Apply `function` to `arguments` and return the result value.""",
            "builtins/basic.kt:907:1")

    LBuiltin("apply", ::bi_apply,
            /* std */ arrayOf<String>("function"),
            noKey,
            noOpt,
            /* rest */ "args+",
            /* ret */ "value",
            /* special */ false,
            """
Apply `function` to `args+` and return the result value.
`args+` is a spreadable argument list, meaning the last argument (meant
to be a list) is appended to the previous ones.""",
            "builtins/basic.kt:928:1")

    LBuiltin("environmentp", ::bi_environmentp,
            /* std */ arrayOf<String>("object"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t if `object` is an environment, else nil.""",
            "builtins/basic.kt:948:1")

    LBuiltin("errorp", ::bi_errorp,
            /* std */ arrayOf<String>("object"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t if `object` is an error object, else nil.""",
            "builtins/basic.kt:966:1")

    LBuiltin("stringp", ::bi_stringp,
            /* std */ arrayOf<String>("object"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t is `object` is a string, else nil.""",
            "builtins/basic.kt:984:1")

    LBuiltin("numberp", ::bi_numberp,
            /* std */ arrayOf<String>("object"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t is `object` is a number, else nil.""",
            "builtins/basic.kt:1002:1")

    LBuiltin("consp", ::bi_consp,
            /* std */ arrayOf<String>("object"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t is `object` is a cons cell, else nil.""",
            "builtins/basic.kt:1020:1")

    LBuiltin("regexpp", ::bi_regexpp,
            /* std */ arrayOf<String>("object"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t is `object` is a regexp, else nil.""",
            "builtins/basic.kt:1038:1")

    LBuiltin("symbolp", ::bi_symbolp,
            /* std */ arrayOf<String>("object"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t if `object` is a symbol, else nil.""",
            "builtins/basic.kt:1056:1")

    LBuiltin("tablep", ::bi_tablep,
            /* std */ arrayOf<String>("object"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t is `object` is a table, else nil.""",
            "builtins/basic.kt:1074:1")

    LBuiltin("vectorp", ::bi_vectorp,
            /* std */ arrayOf<String>("object"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t is `object` is a vector, else nil.""",
            "builtins/basic.kt:1092:1")

    LBuiltin("listp", ::bi_listp,
            /* std */ arrayOf<String>("object"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t if `object` is a list, else nil.""",
            "builtins/basic.kt:1110:1")

    LBuiltin("sequencep", ::bi_sequencep,
            /* std */ arrayOf<String>("object"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t if `object` is a sequence, else nil.
Lists, strings, and vectors are sequences.""",
            "builtins/basic.kt:1130:1")

    LBuiltin("functionp", ::bi_functionp,
            /* std */ arrayOf<String>("object"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t if `object` is a function, else nil.""",
            "builtins/basic.kt:1153:1")

    LBuiltin("builtinp", ::bi_builtinp,
            /* std */ arrayOf<String>("object"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t if `object` is a builtin function, else nil.""",
            "builtins/basic.kt:1171:1")

    LBuiltin("macrop", ::bi_macrop,
            /* std */ arrayOf<String>("object"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t if `object` is a macro, else nil.""",
            "builtins/basic.kt:1189:1")

    LBuiltin("length", ::bi_length,
            /* std */ arrayOf<String>("sequence"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "number",
            /* special */ false,
            """
Return the length of `sequence` as a number.""",
            "builtins/basic.kt:1207:1")

    LBuiltin("type-of", ::bi_typeof,
            /* std */ arrayOf<String>("object"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "symbol",
            /* special */ false,
            """
Return the type of `object` as a symbol.""",
            "builtins/basic.kt:1225:1")

    LBuiltin("loop", ::bi_loop,
            noStd,
            noKey,
            noOpt,
            /* rest */ "bodyforms",
            /* ret */ "none",
            /* special */ true,
            """
Eval `bodyforms` again and again.""",
            "builtins/basic.kt:1243:1")

    LBuiltin("while", ::bi_while,
            /* std */ arrayOf<String>("condition"),
            noKey,
            noOpt,
            /* rest */ "bodyforms",
            /* ret */ "value",
            /* special */ true,
            """
If `condition` evaluates non-nil, evaluate `bodyforms`; repeat.""",
            "builtins/basic.kt:1263:1")

    LBuiltin("until", ::bi_until,
            /* std */ arrayOf<String>("condition"),
            noKey,
            noOpt,
            /* rest */ "bodyforms",
            /* ret */ "value",
            /* special */ true,
            """
If `condition` evaluates nil, evaluate `bodyforms`; repeat.""",
            "builtins/basic.kt:1286:1")

    LBuiltin("unwind-protect", ::bi_unwind_protect,
            /* std */ arrayOf<String>("bodyform"),
            noKey,
            noOpt,
            /* rest */ "cleanupforms",
            /* ret */ "value",
            /* special */ true,
            """
Eval `bodyform`, and even in case of an error or throw, eval `cleanupforms`.
If `bodyform` completes normally, return its value after executing the
`cleanupforms`.""",
            "builtins/basic.kt:1311:1")

    LBuiltin("gensym", ::bi_gensym,
            noStd,
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("prefix", makeString("G#")), ),
            noRest,
            /* ret */ "symbol",
            /* special */ false,
            """
Return a new, uninterned and unused symbol with a name prefix \"G#\".
The symbol is not bound or fbound and has an empty property list.
If a different `prefix` is given, it is tried as the name for the
symbol or, if the name is already in use, as the prefix of the name.""",
            "builtins/basic.kt:1337:1")

    LBuiltin("append", ::bi_append,
            noStd,
            noKey,
            noOpt,
            /* rest */ "lists",
            /* ret */ "value",
            /* special */ false,
            """
Return a new list that is the concatenation of `lists`.
The list structure of all but the last list is copied.""",
            "builtins/basic.kt:1370:1")

    LBuiltin("nconc", ::bi_nconc,
            noStd,
            noKey,
            noOpt,
            /* rest */ "lists",
            /* ret */ "value",
            /* special */ false,
            """
Return a new list that is the concatenation of `lists`.
The list structure of all but the last list is modified.""",
            "builtins/basic.kt:1403:1")

    LBuiltin("fset", ::bi_fset,
            /* std */ arrayOf<String>("symbol", "new-func"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "new-func",
            /* special */ false,
            """
Set function of `symbol` to `new-func` (a function) and return `new-func`.""",
            "builtins/basic.kt:1437:1")

    LBuiltin("defvar", ::bi_defvar,
            /* std */ arrayOf<String>("symbol"),
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("initial-value", Nil), Pair("docstring", Nil), ),
            noRest,
            /* ret */ "symbol",
            /* special */ true,
            """
Define variable `symbol` with optional `initial-value` and `docstring`.
If the variable is already bound, its value is not changed.""",
            "builtins/basic.kt:1460:1")

    LBuiltin("defparameter", ::bi_defparameter,
            /* std */ arrayOf<String>("symbol"),
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("initial-value", Nil), Pair("docstring", Nil), ),
            noRest,
            /* ret */ "symbl",
            /* special */ true,
            """
Define variable `symbol` with optional `initial-value` and `docstring`.
If the variable is already bound, its value is changed nonetheless.""",
            "builtins/basic.kt:1490:1")

    LBuiltin("last", ::bi_last,
            /* std */ arrayOf<String>("l"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return the last pair of list `l`, or nil if `l` is nil.""",
            "builtins/basic.kt:1518:1")

    LBuiltin("read", ::bi_read,
            noStd,
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("input-stream", Nil), Pair("eof-error-p", Nil), Pair("eof-value", Nil), ),
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Read an expression from `input-stream` (or stdin) and return it.
`input-stream` may be a stream or a string.""",
            "builtins/basic.kt:1541:1")

    LBuiltin("flet", ::bi_flet,
            /* std */ arrayOf<String>("bindings"),
            noKey,
            noOpt,
            /* rest */ "bodyforms",
            /* ret */ "value",
            /* special */ true,
            """
Bind one or more functions to symbols and evaluate `bodyforms`.
The `bindings` are of the form (symbol (lambda-list) . bodyforms).""",
            "builtins/basic.kt:1581:1")

    LBuiltin("symbol-name", ::bi_symbol_name,
            /* std */ arrayOf<String>("symbol"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "string",
            /* special */ false,
            """
Return the name of `symbol` as a string.""",
            "builtins/basic.kt:1619:1")

    LBuiltin("atom", ::bi_atom,
            /* std */ arrayOf<String>("object"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t if `arg` is atomic (i.e. symbol, number, string, char), nil else.""",
            "builtins/basic.kt:1637:1")

    LBuiltin("equal", ::bi_equal,
            /* std */ arrayOf<String>("obj1", "obj1"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return non-nil iff the arguments are the same or have the same contents.""",
            "builtins/basic.kt:1655:1")

    LBuiltin("eval", ::bi_eval,
            /* std */ arrayOf<String>("expr"),
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("environment", Nil), ),
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Evaluate `expr` in optional `environment` and return the value.
`environment` may be nil, in which case the current environment is used.""",
            "builtins/basic.kt:1675:1")

    LBuiltin("get", ::bi_getprop,
            /* std */ arrayOf<String>("symbol", "property"),
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("default-value", Nil), ),
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return the value of `symbol`'s property `property` (or nil, if not set).""",
            "builtins/basic.kt:1700:1")

    LBuiltin("put", ::bi_putprop,
            /* std */ arrayOf<String>("symbol", "property", "value"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return the value of `symbol`'s property `property` (or nil, if not set).""",
            "builtins/basic.kt:1721:1")

    LBuiltin("remprop", ::bi_remprop,
            /* std */ arrayOf<String>("symbol", "property"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Remove `property` from `symbol` and return the previous value (or Nil).""",
            "builtins/basic.kt:1743:1")

    LBuiltin("reverse", ::bi_reverse,
            /* std */ arrayOf<String>("sequence"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "list",
            /* special */ false,
            """
Reverse `sequence` (by copying) and return the result.
The resulting sequence does not share structure with the argument list.""",
            "builtins/basic.kt:1765:1")

    LBuiltin("nreverse", ::bi_nreverse,
            /* std */ arrayOf<String>("list"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "list",
            /* special */ false,
            """
Reverse `list` (maybe by modifying a list's cdrs) and return the result.""",
            "builtins/basic.kt:1783:1")

    LBuiltin("mapcar", ::bi_mapcar,
            /* std */ arrayOf<String>("function"),
            noKey,
            noOpt,
            /* rest */ "lists+",
            /* ret */ "value-list`",
            /* special */ false,
            """
Apply `function` to the first members of the argument lists, then the
second and so on; return the list of resulting values. Any excess
values are discarded.
Example:
  (mapcar #'cons '(3 4 5) '(a b c d))
  => ((3 . a) (4 . b) (5 . c))""",
            "builtins/basic.kt:1819:1")

    LBuiltin("rplaca-ret-value", ::bi_rplaca_ret_value,
            /* std */ arrayOf<String>("cons", "new-car"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "new-car",
            /* special */ false,
            """
Replace the car of `cons` with `new-car` and return `new-car`.
Intended for use by setf.""",
            "builtins/basic.kt:1866:1")

    LBuiltin("rplacd-ret-value", ::bi_rplacd_ret_value,
            /* std */ arrayOf<String>("cons", "new-cdr"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "new-cdr",
            /* special */ false,
            """
Replace the cdr of `cons` with `new-car` and return `new-cdr`.
Intended for use by setf.""",
            "builtins/basic.kt:1887:1")

    LBuiltin("function-body", ::bi_function_body,
            /* std */ arrayOf<String>("function"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "bodyforms",
            /* special */ false,
            """
Return the body forms of `function`.
The returned object is a list of the actual body forms of the function,
not a copy; modifying it will have direct impact on the function's
behaviour.""",
            "builtins/basic.kt:1910:1")

    LBuiltin("identity", ::bi_identity,
            /* std */ arrayOf<String>("arg"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "arg",
            /* special */ false,
            """
Return `arg` unchanged.""",
            "builtins/basic.kt:1928:1")

    LBuiltin("ignore", ::bi_ignore,
            noStd,
            noKey,
            noOpt,
            /* rest */ "args",
            /* ret */ "nil",
            /* special */ false,
            """
Return nil""",
            "builtins/basic.kt:1946:1")

    LBuiltin("nth", ::bi_nth,
            /* std */ arrayOf<String>("n", "list"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "object",
            /* special */ false,
            """
Return the `n`th element of `list`.""",
            "builtins/basic.kt:1964:1")

    LBuiltin("nthcdr", ::bi_nthcdr,
            /* std */ arrayOf<String>("n", "list"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "object",
            /* special */ false,
            """
Return the `n`th cons of `list`.""",
            "builtins/basic.kt:1992:1")

    LBuiltin("charp", ::bi_charp,
            /* std */ arrayOf<String>("object"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t iff `object` is a character, nil else.""",
            "builtins/basic.kt:2020:1")

    LBuiltin("lambdap", ::bi_lambdap,
            /* std */ arrayOf<String>("object"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t iff `object` is a lambda, nil else.""",
            "builtins/basic.kt:2038:1")

    LBuiltin("keywordp", ::bi_keywordp,
            /* std */ arrayOf<String>("expr"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t if the argument is a keyword symbol, nil otherwise.
A keyword is a symbol whose name starts with a colon, but is
longer than just the colon.""",
            "builtins/basic.kt:2058:1")

    LBuiltin("code-char", ::bi_code_char,
            /* std */ arrayOf<String>("code"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "char",
            /* special */ false,
            """
Return a character with the code attribute given by `code`. If no such
character exists and one cannot be created, return nil.""",
            "builtins/chars.kt:18:1")

    LBuiltin("char-int", ::bi_char_int,
            /* std */ arrayOf<String>("char"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "code",
            /* special */ false,
            """
Return a non-negative integer encoding the `char` object.
`char` may also be a string of length 1.""",
            "builtins/chars.kt:41:1")

    LBuiltin("char-equal", ::bi_char_equal,
            noStd,
            noKey,
            noOpt,
            /* rest */ "characters",
            /* ret */ "t/nil",
            /* special */ false,
            """
Return true iff all characters are the same except for case.""",
            "builtins/chars.kt:141:1")

    LBuiltin("char-not-equal", ::bi_char_not_equal,
            noStd,
            noKey,
            noOpt,
            /* rest */ "characters",
            /* ret */ "t/nil",
            /* special */ false,
            """
Return true iff all characters are unequal, without regarding case.""",
            "builtins/chars.kt:159:1")

    LBuiltin("char/=", ::bi_char_not_equal2,
            noStd,
            noKey,
            noOpt,
            /* rest */ "characters",
            /* ret */ "t/nil",
            /* special */ false,
            """
Return true iff all given characters are unequal to each other.""",
            "builtins/chars.kt:177:1")

    LBuiltin("char<", ::bi_char_lt,
            noStd,
            noKey,
            noOpt,
            /* rest */ "characters",
            /* ret */ "t/nil",
            /* special */ false,
            """
Return true iff the characters are monotonically increasing.""",
            "builtins/chars.kt:195:1")

    LBuiltin("char-lessp", ::bi_char_lessp,
            noStd,
            noKey,
            noOpt,
            /* rest */ "characters",
            /* ret */ "t/nil",
            /* special */ false,
            """
Return true iff the characters are monotonically increasing.""",
            "builtins/chars.kt:215:1")

    LBuiltin("char<=", ::bi_char_le,
            noStd,
            noKey,
            noOpt,
            /* rest */ "characters",
            /* ret */ "t/nil",
            /* special */ false,
            """
Return true if the characters are monotonically non-decreasing.""",
            "builtins/chars.kt:235:1")

    LBuiltin("char-not-greaterp", ::bi_char_not_greaterp,
            noStd,
            noKey,
            noOpt,
            /* rest */ "characters",
            /* ret */ "t/nil",
            /* special */ false,
            """
Return true if the characters are monotonically non-decreasing.""",
            "builtins/chars.kt:255:1")

    LBuiltin("char=", ::bi_char_eql,
            noStd,
            noKey,
            noOpt,
            /* rest */ "characters",
            /* ret */ "t/nil",
            /* special */ false,
            """
Return true if the characters are all equal.""",
            "builtins/chars.kt:275:1")

    LBuiltin("char>", ::bi_char_gt,
            noStd,
            noKey,
            noOpt,
            /* rest */ "characters",
            /* ret */ "t/nil",
            /* special */ false,
            """
Return true iff the characters are monotonically decreasing.""",
            "builtins/chars.kt:293:1")

    LBuiltin("char-greaterp", ::bi_char_greaterp,
            noStd,
            noKey,
            noOpt,
            /* rest */ "characters",
            /* ret */ "t/nil",
            /* special */ false,
            """
Return true iff the characters are monotonically decreasing.""",
            "builtins/chars.kt:313:1")

    LBuiltin("char>=", ::bi_char_ge,
            noStd,
            noKey,
            noOpt,
            /* rest */ "characters",
            /* ret */ "t/nil",
            /* special */ false,
            """
Return true iff the characters are monotonically not increasing.""",
            "builtins/chars.kt:333:1")

    LBuiltin("char-not-lessp", ::bi_char_not_lessp,
            noStd,
            noKey,
            noOpt,
            /* rest */ "characters",
            /* ret */ "t/nil",
            /* special */ false,
            """
Return true iff the characters are monotonically not increasing.""",
            "builtins/chars.kt:353:1")

    LBuiltin("caar", ::bi_caar,
            /* std */ arrayOf<String>("list"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return the caar of `list`.""",
            "builtins/cxr.kt:16:1")

    LBuiltin("cadr", ::bi_cadr,
            /* std */ arrayOf<String>("list"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return the cadr of `list`.""",
            "builtins/cxr.kt:34:1")

    LBuiltin("cdar", ::bi_cdar,
            /* std */ arrayOf<String>("list"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return the cdar of `list`.""",
            "builtins/cxr.kt:52:1")

    LBuiltin("cddr", ::bi_cddr,
            /* std */ arrayOf<String>("list"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return the cddr of `list`.""",
            "builtins/cxr.kt:70:1")

    LBuiltin("caaar", ::bi_caaar,
            /* std */ arrayOf<String>("list"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return the caaar of `list`.""",
            "builtins/cxr.kt:88:1")

    LBuiltin("caadr", ::bi_caadr,
            /* std */ arrayOf<String>("list"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return the caadr of `list`.""",
            "builtins/cxr.kt:106:1")

    LBuiltin("cadar", ::bi_cadar,
            /* std */ arrayOf<String>("list"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return the cadar of `list`.""",
            "builtins/cxr.kt:124:1")

    LBuiltin("caddr", ::bi_caddr,
            /* std */ arrayOf<String>("list"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return the caddr of `list`.""",
            "builtins/cxr.kt:142:1")

    LBuiltin("cdaar", ::bi_cdaar,
            /* std */ arrayOf<String>("list"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return the cdaar of `list`.""",
            "builtins/cxr.kt:160:1")

    LBuiltin("cdadr", ::bi_cdadr,
            /* std */ arrayOf<String>("list"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return the cdadr of `list`.""",
            "builtins/cxr.kt:178:1")

    LBuiltin("cddar", ::bi_cddar,
            /* std */ arrayOf<String>("list"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return the cddar of `list`.""",
            "builtins/cxr.kt:196:1")

    LBuiltin("cdddr", ::bi_cdddr,
            /* std */ arrayOf<String>("list"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return the cdddr of `list`.""",
            "builtins/cxr.kt:214:1")

    LBuiltin("caaaar", ::bi_caaaar,
            /* std */ arrayOf<String>("list"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return the caaaar of `list`.""",
            "builtins/cxr.kt:233:1")

    LBuiltin("caaadr", ::bi_caaadr,
            /* std */ arrayOf<String>("list"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return the caaadr of `list`.""",
            "builtins/cxr.kt:251:1")

    LBuiltin("caadar", ::bi_caadar,
            /* std */ arrayOf<String>("list"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return the caadar of `list`.""",
            "builtins/cxr.kt:269:1")

    LBuiltin("caaddr", ::bi_caaddr,
            /* std */ arrayOf<String>("list"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return the caaddr of `list`.""",
            "builtins/cxr.kt:287:1")

    LBuiltin("cadaar", ::bi_cadaar,
            /* std */ arrayOf<String>("list"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return the cadaar of `list`.""",
            "builtins/cxr.kt:305:1")

    LBuiltin("cadadr", ::bi_cadadr,
            /* std */ arrayOf<String>("list"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return the cadadr of `list`.""",
            "builtins/cxr.kt:323:1")

    LBuiltin("caddar", ::bi_caddar,
            /* std */ arrayOf<String>("list"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return the caddar of `list`.""",
            "builtins/cxr.kt:341:1")

    LBuiltin("cadddr", ::bi_cadddr,
            /* std */ arrayOf<String>("list"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return the cadddr of `list`.""",
            "builtins/cxr.kt:359:1")

    LBuiltin("cdaaar", ::bi_cdaaar,
            /* std */ arrayOf<String>("list"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return the cdaaar of `list`.""",
            "builtins/cxr.kt:377:1")

    LBuiltin("cdaadr", ::bi_cdaadr,
            /* std */ arrayOf<String>("list"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return the cdaadr of `list`.""",
            "builtins/cxr.kt:395:1")

    LBuiltin("cdadar", ::bi_cdadar,
            /* std */ arrayOf<String>("list"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return the cdadar of `list`.""",
            "builtins/cxr.kt:413:1")

    LBuiltin("cdaddr", ::bi_cdaddr,
            /* std */ arrayOf<String>("list"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return the cdaddr of `list`.""",
            "builtins/cxr.kt:431:1")

    LBuiltin("cddaar", ::bi_cddaar,
            /* std */ arrayOf<String>("list"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return the cddaar of `list`.""",
            "builtins/cxr.kt:449:1")

    LBuiltin("cddadr", ::bi_cddadr,
            /* std */ arrayOf<String>("list"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return the cddadr of `list`.""",
            "builtins/cxr.kt:467:1")

    LBuiltin("cdddar", ::bi_cdddar,
            /* std */ arrayOf<String>("list"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return the cdddar of `list`.""",
            "builtins/cxr.kt:485:1")

    LBuiltin("cddddr", ::bi_cddddr,
            /* std */ arrayOf<String>("list"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return the cddddr of `list`.""",
            "builtins/cxr.kt:503:1")

    LBuiltin("new-environment", ::bi_new_environment,
            noStd,
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("parent-environment", T), Pair("value-table", Nil), ),
            noRest,
            /* ret */ "environment",
            /* special */ false,
            """
Return a new environment. Optional `parent-environment` is the parent,
otherwise the current environment. If `parent-environment` is nil, there
is no parent environment, i.e. a top-level environment is created; if
`parent-environmenta is t (the default), the parent is the current
environment. If `value-table` is non-nil, it is a table with symbol/value
pairs to populate the new environment.""",
            "builtins/environments.kt:21:1")

    LBuiltin("the-environment", ::bi_the_environment,
            noStd,
            noKey,
            noOpt,
            noRest,
            /* ret */ "environment",
            /* special */ false,
            """
Return the current environment.""",
            "builtins/environments.kt:64:1")

    LBuiltin("with-environment", ::bi_with_environment,
            /* std */ arrayOf<String>("env"),
            noKey,
            noOpt,
            /* rest */ "bodyforms",
            /* ret */ "value",
            /* special */ true,
            """
Eval `bodyforms` in environment `env` and return the last value.""",
            "builtins/environments.kt:82:1")

    LBuiltin("root-environment", ::bi_root_environment,
            noStd,
            noKey,
            noOpt,
            noRest,
            /* ret */ "root-environment",
            /* special */ false,
            """
Return the root environment.""",
            "builtins/environments.kt:108:1")

    LBuiltin("factor", ::bi_factor,
            /* std */ arrayOf<String>("int"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "factor-list",
            /* special */ false,
            """
Return the list of prime factors of `int`.""",
            "builtins/factor.kt:119:1")

    LBuiltin("prime-number-p", ::bi_prime_number_p,
            /* std */ arrayOf<String>("integer"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return true iff `integer` is a prime number.""",
            "builtins/factor.kt:142:1")

    LBuiltin("next-prime", ::bi_next_prime,
            /* std */ arrayOf<String>("integer"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "prime",
            /* special */ false,
            """
Return the next prime number greater than `integer`.""",
            "builtins/factor.kt:160:1")

    LBuiltin("known-primes", ::bi_known_primes,
            noStd,
            noKey,
            noOpt,
            noRest,
            /* ret */ "prime-list",
            /* special */ false,
            """
Return a list of the consecutive prime numbers known so far.""",
            "builtins/factor.kt:178:1")

    LBuiltin("basename", ::bi_basename,
            /* std */ arrayOf<String>("pathspec"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "file-basename",
            /* special */ false,
            """
Return the basename of a pathname, meaning without the directory part(s).""",
            "builtins/files.kt:21:1")

    LBuiltin("dirname", ::bi_dirname,
            /* std */ arrayOf<String>("pathspec"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "file-dirname",
            /* special */ false,
            """
Return the dirname of a pathname, meaning only the directory part(s).""",
            "builtins/files.kt:40:1")

    LBuiltin("directory", ::bi_directory,
            /* std */ arrayOf<String>("pathspec"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "pathnames",
            /* special */ false,
            """
Return a list of pathnames matching `pathspec`.
The last path component may contain wildcard characters.""",
            "builtins/files.kt:60:1")

    LBuiltin("delete-file", ::bi_delete_file,
            /* std */ arrayOf<String>("pathname"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t",
            /* special */ false,
            """
Delete the file denoted by `pathname` and return t on success.
On failure, signal an error.""",
            "builtins/files.kt:80:1")

    LBuiltin("file-author", ::bi_file_author,
            /* std */ arrayOf<String>("pathspec"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "string",
            /* special */ false,
            """
Return the author of the file `pathname`.
The pathspec is either a pathname string or an open stream.""",
            "builtins/files.kt:117:1")

    LBuiltin("file-length", ::bi_file_length,
            /* std */ arrayOf<String>("pathspec"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "number",
            /* special */ false,
            """
Return the length of the file `pathspec` in bytes.
The pathspec is either a pathname string or an open stream.""",
            "builtins/files.kt:137:1")

    LBuiltin("expand-file-name", ::bi_expand_file_name,
            /* std */ arrayOf<String>("filename"),
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("default-directory", Nil), ),
            noRest,
            /* ret */ "pathname",
            /* special */ false,
            """
Convert `filename` to absolute, and canonicalize it.
Second arg `default-directory` is the directory to start with if
NAME is relative (does not start with slash or tilde).
If DEFAULT-DIRECTORY is nil or missing, the process's current working
directory is used.
`filename` should be a string that is a valid file name for the
underlying filesystem.

File name components that are . are removed, and so are file name
components followed by .., along with the .. itself; note that
these simplifications are done without checking the resulting file
names in the file system.

Multiple consecutive slashes are collapsed into a single slash.

An initial "~" in `filename` expands to your home directory.
An initial "~USER" in `filename` expands to USERs home directory.
If USER doesnt exist, "~USER" is not expanded.
[This function documentation is copied from GNU Emacs, with a few
changes.]""",
            "builtins/files.kt:188:1")

    LBuiltin("get-working-directory", ::bi_get_working_directory,
            noStd,
            noKey,
            noOpt,
            noRest,
            /* ret */ "pathname",
            /* special */ false,
            """
Return the current working directory as a string.""",
            "builtins/files.kt:226:1")

    LBuiltin("user-homedir-pathname", ::bi_user_homedir_pathname,
            noStd,
            noKey,
            noOpt,
            noRest,
            /* ret */ "pathname",
            /* special */ false,
            """
Return the pathname of the user's home directory.""",
            "builtins/files.kt:244:1")

    LBuiltin("namestring", ::bi_namestring,
            /* std */ arrayOf<String>("pathname"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "normalized-pathname",
            /* special */ false,
            """
Return `pathspec` as a pathname in normalized form.
This means multiple consecutive slashes and /./ are reduced to a single
slash, and /../ constructs are resolved.""",
            "builtins/files.kt:280:1")

    LBuiltin("probe-file", ::bi_probe_file,
            /* std */ arrayOf<String>("pathspec"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "result",
            /* special */ false,
            """
If the file `pathspec` exists, return its truename, else nil.""",
            "builtins/files.kt:298:1")

    LBuiltin("directory-p", ::bi_directory_p,
            /* std */ arrayOf<String>("pathspec"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t if the file denoted by `pathspec` is a directory, nil else.""",
            "builtins/files.kt:320:1")

    LBuiltin("plain-file-p", ::bi_plain_file_p,
            /* std */ arrayOf<String>("pathspec"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t if the file denoted by `pathspec` is a plain file, nil else.""",
            "builtins/files.kt:339:1")

    LBuiltin("symlink-p", ::bi_symlink_p,
            /* std */ arrayOf<String>("pathspec"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t if the file denoted by `pathspec` is a plain file, nil else.""",
            "builtins/files.kt:358:1")

    LBuiltin("println", ::bi_println,
            noStd,
            /* key */ mapOf<String, LObject>("sep" to makeString(" ")),
            noOpt,
            /* rest */ "args",
            /* ret */ "*the-non-printing-object*",
            /* special */ false,
            """
Print all arguments, separated by :sep, terminated by a newline.""",
            "builtins/io.kt:34:1")

    LBuiltin("print", ::bi_print,
            /* std */ arrayOf<String>("arg"),
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("output-stream", Nil), ),
            noRest,
            /* ret */ "arg",
            /* special */ false,
            """
Print `arg` to `stream` (or standard output) suitable for input to (read),
with quoting and escaping where necessary, preceded by a newline and
followed by a blank.""",
            "builtins/io.kt:55:1")

    LBuiltin("prin1", ::bi_prin1,
            /* std */ arrayOf<String>("arg"),
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("output-stream", Nil), ),
            noRest,
            /* ret */ "arg",
            /* special */ false,
            """
Print `arg` to `stream` (or standard output) suitable for input to (read),
with quoting and escaping where necessary.""",
            "builtins/io.kt:76:1")

    LBuiltin("prin1-to-string", ::bi_prin1_to_string,
            /* std */ arrayOf<String>("arg"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "string",
            /* special */ false,
            """
Print `arg` to a string as with prin1 and return the string.""",
            "builtins/io.kt:96:1")

    LBuiltin("princ", ::bi_princ,
            /* std */ arrayOf<String>("arg"),
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("output-stream", Nil), ),
            noRest,
            /* ret */ "arg",
            /* special */ false,
            """
Print `arg` to `stream` (or standard output) without quoting or escaping.""",
            "builtins/io.kt:114:1")

    LBuiltin("princ-to-string", ::bi_princs,
            /* std */ arrayOf<String>("arg"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "string",
            /* special */ false,
            """
Print `arg` to a string without quoting or escaping and return the string.
Also known as princs.""",
            "builtins/io.kt:135:1")

    LBuiltin("princs", ::bi_princs,
            /* std */ arrayOf<String>("arg"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "string",
            /* special */ false,
            """
Print `arg` to a string without quoting or escaping and return the string.
Also known as princ-to-string.""",
            "builtins/io.kt:149:1")

    LBuiltin("terpri", ::bi_terpri,
            noStd,
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("output-stream", Nil), ),
            noRest,
            /* ret */ "nil",
            /* special */ false,
            """
Terminate a print line by sending a newline to the output-stream
(or standard output).""",
            "builtins/io.kt:168:1")

    LBuiltin("load", ::bi_load,
            /* std */ arrayOf<String>("filename"),
            /* key */ mapOf<String, LObject>("verbose" to T, "print" to Nil, "error" to T),
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Load specified file; return t if the contents was evaluated without error.
If the filename contains a slash, it is used exactly as given. Otherwise,
try to find the load file in the directories named in *load-path*. Try the
filename as given, then with a ".l" suffix, then with  a ".lisp" suffix.
If keyword verbose is nil (the default is true), do not print an
informational message after loading.
If keyword `error` is nil (the default is true), do not raise an error for
an unfound file, but return nil instead.
If keyword `print` is true, (the default is nil), the load progress is
shown by printing the values of the top-level forms evaluated. Otherwise,
the value of the variable *load-print* is used to determine printing.""",
            "builtins/io.kt:199:1")

    LBuiltin("make-string-input-stream", ::bi_make_string_input_stream,
            /* std */ arrayOf<String>("string"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "stream",
            /* special */ false,
            """
Return a string input stream. This stream will supply, in order, the
characters in the string.""",
            "builtins/io.kt:224:1")

    LBuiltin("stream", ::bi_stream,
            /* std */ arrayOf<String>("object"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "stream",
            /* special */ false,
            """
Return an input stream from `object`.
If `object` is a stream, return it. Otherwise take the string
representation of `object` and make a stream from that.""",
            "builtins/io.kt:245:1")

    LBuiltin("format", ::bi_format,
            /* std */ arrayOf<String>("destination", "format-string"),
            noKey,
            noOpt,
            /* rest */ "args",
            /* ret */ "nil-or-string",
            /* special */ false,
            """
Format `args` according to `format-string` and write to `dest` (stream,
t, or nil). nil means return the result as a string, t means write to
standard output.
The format string is modeled after Common Lisp's, but lacks many of its
properties. Currently the following format directives are implemented:
  ~A : Aesthetic
  ~S : Standard
  ~C : Character
  ~F : Fixed format floating point
  ~% : Newline
  ~& : Fresh line
  ~| : Page separator
  ~~ : Tilde
  ~#\Newline : Ignored newline""",
            "builtins/io.kt:281:1")

    LBuiltin("open", ::bi_open,
            /* std */ arrayOf<String>("fname"),
            /* key */ mapOf<String, LObject>("if-does-not-exist" to intern(":error"), "direction" to intern(":input"), "if-exists" to intern(":overwrite")),
            noOpt,
            noRest,
            /* ret */ "stream",
            /* special */ false,
            """
Open a file (or reopen a stream) and return the connected stream.
Options: :direction followed by :input or :output or :io,
:if-exists followed by :new-version or :append or :overwrite
or :supersede or :error or nil
:if-does-not-exist followed by :error or :create or nil""",
            "builtins/io.kt:317:1")

    LBuiltin("close", ::bi_close,
            /* std */ arrayOf<String>("stream"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Close an open stream. Return t if the stream was open, nil else""",
            "builtins/io.kt:379:1")

    LBuiltin("read-line", ::bi_read_line,
            noStd,
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("input-stream", Nil), Pair("eof-error-p", T), Pair("eof-value", Nil), Pair("trim-nl", Nil), ),
            noRest,
            /* ret */ "line",
            /* special */ false,
            """
Read a line from *stdin* (or `input-stream`) and return it as a string.
If `eof-error-p` is true (which is the default), raise an error on EOF.
Otherwise, return `eof-value` instead.
If `trim-nl` is true, trim a trailin newline character from the line.""",
            "builtins/io.kt:405:1")

    LBuiltin("make-string-output-stream", ::bi_make_string_output_stream,
            noStd,
            noKey,
            noOpt,
            noRest,
            /* ret */ "string-stream",
            /* special */ false,
            """
Return a output string stream that stores the text that is output to it.
See get-output-stream-string for returning the contents of that stream.""",
            "builtins/io.kt:438:1")

    LBuiltin("get-output-stream-string", ::bi_get_output_stream_string,
            /* std */ arrayOf<String>("string-output-stream"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "string",
            /* special */ false,
            """
Return a string with the contents written to `string-output-stream`.
This operation clears any characters on `string-output-stream`, so
the string contains only those characters which have been output since
the last call to get-output-stream-string or since the creation of the
string-output-stream, whichever occurred most recently.""",
            "builtins/io.kt:460:1")

    LBuiltin("console-reader-stream-p", ::bi_console_reader_stream_p,
            /* std */ arrayOf<String>("object"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t iff `object` is a console reader stream, nil else.""",
            "builtins/io.kt:483:1")

    LBuiltin("file-reader-stream-p", ::bi_file_reader_stream_p,
            /* std */ arrayOf<String>("object"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t iff `object` is a file reader stream, nil else.""",
            "builtins/io.kt:502:1")

    LBuiltin("string-reader-stream-p", ::bi_string_reader_stream_p,
            /* std */ arrayOf<String>("object"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t iff `object` is a string reader stream, nil else.""",
            "builtins/io.kt:521:1")

    LBuiltin("string-writer-stream-p", ::bi_string_writer_stream_p,
            /* std */ arrayOf<String>("object"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t iff `object` is a string writer stream, nil else.""",
            "builtins/io.kt:540:1")

    LBuiltin("file-writer-stream-p", ::bi_file_writer_stream_p,
            /* std */ arrayOf<String>("object"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t iff `object` is a file writer stream, nil else.""",
            "builtins/io.kt:559:1")

    LBuiltin("file-io-stream-p", ::bi_file_io_stream_p,
            /* std */ arrayOf<String>("object"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t iff `object` is a file io stream, nil else.""",
            "builtins/io.kt:577:1")

    LBuiltin("streamp", ::bi_streamp,
            /* std */ arrayOf<String>("object"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t iff `object` is a stream, nil else.""",
            "builtins/io.kt:595:1")

    LBuiltin("finish-output", ::bi_finish_output,
            noStd,
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("output-stream", Nil), ),
            noRest,
            /* ret */ "nil",
            /* special */ false,
            """
Flush pending output to `output-stream` and then return.
If `output-stream` is not specified, use *stdout*.""",
            "builtins/io.kt:614:1")

    LBuiltin("open-interactive-stream", ::bi_open_interactive_stream,
            noStd,
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("prompt", makeString("")), ),
            noRest,
            /* ret */ "interactive-stream",
            /* special */ false,
            """
Return an interactive input stream.
This is a stream from which can be read using the interactive line
editor with `prompt`. If `prompt` is a function, it will be called
with no arguments for every line, and its return value will be used
as the line editor prompt.""",
            "builtins/io.kt:644:1")

    LBuiltin("input-stream-p", ::bi_input_stream_p,
            /* std */ arrayOf<String>("object"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t if `object` is an input stream, nil else.""",
            "builtins/io.kt:662:1")

    LBuiltin("output-stream-p", ::bi_output_stream_p,
            /* std */ arrayOf<String>("object"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t if `object` is an output stream, nil else.""",
            "builtins/io.kt:684:1")

    LBuiltin("interactive-stream-p", ::bi_interactive_stream_p,
            /* std */ arrayOf<String>("object"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t if `object` is an interactive stream, nil else.""",
            "builtins/io.kt:706:1")

    LBuiltin("open-stream-p", ::bi_open_stream_p,
            /* std */ arrayOf<String>("object"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t if `object` is an open stream, nil else.""",
            "builtins/io.kt:728:1")

    LBuiltin("write-string", ::bi_write_string,
            /* std */ arrayOf<String>("string"),
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("output-stream", Nil), ),
            noRest,
            /* ret */ "string",
            /* special */ false,
            """
Write the `string` to `output-stream`.
Keyword parameters `start` and `end`, if specified, denote the start
and end positions of the portion of `string` being written.
Return `string`.""",
            "builtins/io.kt:789:1")

    LBuiltin("write-line", ::bi_write_line,
            /* std */ arrayOf<String>("string"),
            /* key */ mapOf<String, LObject>("start" to Nil, "end" to Nil),
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("output-stream", Nil), ),
            noRest,
            /* ret */ "string",
            /* special */ false,
            """
Write the `string` to `output-stream`, then output a newline afterwards.
Keyword parameters `start` and `end`, if specified, denote the start
and end positions of the portion of `string` being written.
Return `string`.""",
            "builtins/io.kt:810:1")

    LBuiltin("defmacro", ::bi_defmacro,
            /* std */ arrayOf<String>("name", "lambda-list"),
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("docstring", Nil), ),
            /* rest */ "bodyforms",
            /* ret */ "name",
            /* special */ true,
            """
Create a macro with name `name`, parameters `lambda-list`, and `bodyforms`.
`params` is a list of parameter symbols for the function.
Optional `docstring` should describe what the function does.
Return the function symbol `name`.

On calling the function, `bodyforms` will be evaluated in an environment
with the parameters bound to the actual arguments. The value of the last
form evaluated will be returned.""",
            "builtins/macros.kt:23:1")

    LBuiltin("macroexpand", ::bi_macroexpand,
            /* std */ arrayOf<String>("form"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "expanded-form",
            /* special */ false,
            """
Expand macros in `form` and return the expanded form.
macroexpand repeatedly expands form until it is no longer a macro form.""",
            "builtins/macros.kt:48:1")

    LBuiltin("macroexpand-1", ::bi_macroexpand_1,
            /* std */ arrayOf<String>("form"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "expanded-form",
            /* special */ false,
            """
Do one step of macro expansion in `form` and return the expanded form.""",
            "builtins/macros.kt:66:1")

    LBuiltin("quasiquote", ::bi_quasiquote,
            /* std */ arrayOf<String>("expr"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "expanded-form",
            /* special */ true,
            """
In `expr`, replace unquoted items them with their values as appropriate.
Return the resulting form.

unquote-splicing (,@). In the latter case, if the value is a list,
splice it into the surrounding list.""",
            "builtins/macros.kt:125:1")

    LBuiltin("unquote", ::bi_unquote,
            /* std */ arrayOf<String>("form"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "no-return",
            /* special */ true,
            """
Throw an error if called as a function outside of a quasiquote.""",
            "builtins/macros.kt:143:1")

    LBuiltin("unquote-splicing", ::bi_unquote_splicing,
            /* std */ arrayOf<String>("form"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "no-return",
            /* special */ false,
            """
Throw an error if called as a function outside of a quasiquote.""",
            "builtins/macros.kt:161:1")

    LBuiltin("+", ::bi_plus,
            noStd,
            noKey,
            noOpt,
            /* rest */ "numbers",
            /* ret */ "sum",
            /* special */ false,
            """
Return the sum of the NUMBERS.""",
            "builtins/numbers.kt:19:1")

    LBuiltin("-", ::bi_minus,
            /* std */ arrayOf<String>("num1"),
            noKey,
            noOpt,
            /* rest */ "numbers",
            /* ret */ "number",
            /* special */ false,
            """
Return NUM1 minus all NUMBERS, or the negation of sole arg NUM1.""",
            "builtins/numbers.kt:43:1")

    LBuiltin("*", ::bi_mult,
            noStd,
            noKey,
            noOpt,
            /* rest */ "numbers",
            /* ret */ "product",
            /* special */ false,
            """
Return the product of all NUMBERS.""",
            "builtins/numbers.kt:71:1")

    LBuiltin("/", ::bi_div,
            /* std */ arrayOf<String>("num1"),
            noKey,
            noOpt,
            /* rest */ "numbers",
            /* ret */ "number",
            /* special */ false,
            """
Return NUM1 divided by all NUMBERS, or the inverse of sole arg NUM1.""",
            "builtins/numbers.kt:94:1")

    LBuiltin("zerop", ::bi_zerop,
            /* std */ arrayOf<String>("number"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t if number is zero, nil otherwise""",
            "builtins/numbers.kt:121:1")

    LBuiltin("abs", ::bi_abs,
            /* std */ arrayOf<String>("number"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "absolute-value",
            /* special */ false,
            """
Return the absolute value of `number`.""",
            "builtins/numbers.kt:141:1")

    LBuiltin("acos", ::bi_acos,
            /* std */ arrayOf<String>("number"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "radians",
            /* special */ false,
            """
Return the arc cosine of `number`.""",
            "builtins/numbers.kt:159:1")

    LBuiltin("acosh", ::bi_acosh,
            /* std */ arrayOf<String>("number"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "radians",
            /* special */ false,
            """
Return the arc hyperbolic cosine of `number`.""",
            "builtins/numbers.kt:177:1")

    LBuiltin("<", ::bi_cmp_lt,
            noStd,
            noKey,
            noOpt,
            /* rest */ "items",
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t if all `items` are in strictly ascending order, otherwise nil.
Comparable are symbols, numbers, and strings.""",
            "builtins/numbers.kt:197:1")

    LBuiltin(">", ::bi_cmp_gt,
            noStd,
            noKey,
            noOpt,
            /* rest */ "items",
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t if all `items` are in strictly descending order, otherwise nil.
Comparable are symbols, numbers, and strings.""",
            "builtins/numbers.kt:227:1")

    LBuiltin("=", ::bi_cmp_eqv,
            noStd,
            noKey,
            noOpt,
            /* rest */ "items",
            /* ret */ "t/nil",
            /* special */ false,
            """
""",
            "builtins/numbers.kt:256:1")

    LBuiltin("/=", ::bi_cmp_ne,
            noStd,
            noKey,
            noOpt,
            /* rest */ "items",
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t if all `items` are different, otherwise nil.
Comparable are symbols, numbers, and strings.""",
            "builtins/numbers.kt:286:1")

    LBuiltin(">=", ::bi_cmp_ge,
            noStd,
            noKey,
            noOpt,
            /* rest */ "items",
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t if all `items` are in descending order, otherwise nil.
Comparable are symbols, numbers, and strings.""",
            "builtins/numbers.kt:315:1")

    LBuiltin("<=", ::bi_cmp_le,
            noStd,
            noKey,
            noOpt,
            /* rest */ "items",
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t if all `items` are in ascending order, otherwise nil.
Comparable are symbols, numbers, and strings.""",
            "builtins/numbers.kt:345:1")

    LBuiltin("<=>", ::bi_cmp,
            /* std */ arrayOf<String>("item1", "item2"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "number",
            /* special */ false,
            """
Return -1, 0, or 1 if `item1` is less than, equal to, or greater than `item2`.
Comparable are symbols, numbers, and strings.""",
            "builtins/numbers.kt:375:1")

    LBuiltin("%", ::bi_modulo,
            /* std */ arrayOf<String>("num1", "num2"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "modulo",
            /* special */ false,
            """
Return modulo of `num1` divided by `num2` (which must be integers).""",
            "builtins/numbers.kt:395:1")

    LBuiltin("**", ::bi_power,
            /* std */ arrayOf<String>("base", "power"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "number",
            /* special */ false,
            """
Return `base` raised to the power `power`.""",
            "builtins/numbers.kt:417:1")

    LBuiltin("1+", ::bi_1plus,
            /* std */ arrayOf<String>("number"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "number",
            /* special */ false,
            """
Return a value of `number` plus 1.""",
            "builtins/numbers.kt:437:1")

    LBuiltin("1-", ::bi_1minus,
            /* std */ arrayOf<String>("number"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "number",
            /* special */ false,
            """
Return a value of `number` plus 1.""",
            "builtins/numbers.kt:456:1")

    LBuiltin("isqrt", ::bi_isqrt,
            /* std */ arrayOf<String>("number"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "number",
            /* special */ false,
            """
Return the integer square root of `number`.""",
            "builtins/numbers.kt:475:1")

    LBuiltin("ash", ::bi_ash,
            /* std */ arrayOf<String>("integer", "count"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "number",
            /* special */ false,
            """
Return `integer` arithmetically shifted by `count` bit positions.
Ash shifts left if `count` is positive, right if `count` is negative.
The shifted value has the same sign as `integer`.""",
            "builtins/numbers.kt:496:1")

    LBuiltin("asin", ::bi_asin,
            /* std */ arrayOf<String>("number"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "radians",
            /* special */ false,
            """
Return the arc sine of `number`.""",
            "builtins/numbers.kt:521:1")

    LBuiltin("asinh", ::bi_asinh,
            /* std */ arrayOf<String>("number"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "arc-hsine",
            /* special */ false,
            """
Return the arc hyperbolic sine of `number`.""",
            "builtins/numbers.kt:540:1")

    LBuiltin("atan", ::bi_atan,
            /* std */ arrayOf<String>("number"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "radians",
            /* special */ false,
            """
Return the arc tangent of `number`.""",
            "builtins/numbers.kt:559:1")

    LBuiltin("atanh", ::bi_atanh,
            /* std */ arrayOf<String>("number"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "arc-htangent",
            /* special */ false,
            """
Return the arc hyperbolic tangent of `number`.""",
            "builtins/numbers.kt:578:1")

    LBuiltin("easter", ::bi_easter,
            /* std */ arrayOf<String>("year"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "year-month-day",
            /* special */ false,
            """
Calculate the easter date for `year`; return as a list (year month mday).
The formula to calculate the date is according to Lichtenberg as cited by
Wikipedia in
https://de.wikipedia.org/wiki/Gau%C3%9Fsche_Osterformel#Eine_erg.C3.A4nzte_Osterformel""",
            "builtins/numbers.kt:601:1")

    LBuiltin("round", ::bi_round,
            /* std */ arrayOf<String>("number"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "number",
            /* special */ false,
            """
Return `number` rounded to the nearest integer.
Ties (<integer> + 0.5) are rounded towards an even integer.""",
            "builtins/numbers.kt:639:1")

    LBuiltin("fround", ::bi_round,
            /* std */ arrayOf<String>("number"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "number",
            /* special */ false,
            """
Return `number` rounded to the nearest integer.
Ties (<integer> + 0.5) are rounded towards an even integer.""",
            "builtins/numbers.kt:652:1")

    LBuiltin("ceiling", ::bi_ceiling,
            /* std */ arrayOf<String>("number"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "number",
            /* special */ false,
            """
Return `number` truncated to an integer towards positive infinity.""",
            "builtins/numbers.kt:670:1")

    LBuiltin("floor", ::bi_floor,
            /* std */ arrayOf<String>("number"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "number",
            /* special */ false,
            """
Return `number` truncated to an integer towards negative infinity.""",
            "builtins/numbers.kt:688:1")

    LBuiltin("ffloor", ::bi_floor,
            /* std */ arrayOf<String>("number"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "number",
            /* special */ false,
            """
Return `number` truncated to an integer towards negative infinity.""",
            "builtins/numbers.kt:700:1")

    LBuiltin("sqrt", ::bi_sqrt,
            /* std */ arrayOf<String>("number"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "number",
            /* special */ false,
            """
Return the sqare root of `number`.""",
            "builtins/numbers.kt:718:1")

    LBuiltin("integerp", ::bi_integerp,
            /* std */ arrayOf<String>("object"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return true iff object is an integer number""",
            "builtins/numbers.kt:736:1")

    LBuiltin("signum", ::bi_signum,
            /* std */ arrayOf<String>("number"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "sign",
            /* special */ false,
            """
Return -1 / 0 / 1 if NUMBER is negative / zero / positive, respectively.""",
            "builtins/numbers.kt:755:1")

    LBuiltin("evenp", ::bi_evenp,
            /* std */ arrayOf<String>("n"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return a true value iff the number is an even integer.""",
            "builtins/numbers.kt:780:1")

    LBuiltin("oddp", ::bi_oddp,
            /* std */ arrayOf<String>("n"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return a true value iff the number is an odd integer.""",
            "builtins/numbers.kt:806:1")

    LBuiltin("conjugate", ::bi_conjugate,
            noStd,
            noKey,
            noOpt,
            /* rest */ "&rest",
            /* ret */ "nothing",
            /* special */ false,
            """
Function is not implemented; will throw an error.""",
            "builtins/numbers.kt:832:1")

    LBuiltin("cis", ::bi_cis,
            noStd,
            noKey,
            noOpt,
            /* rest */ "&rest",
            /* ret */ "nothing",
            /* special */ false,
            """
Function is not implemented; will throw an error.""",
            "builtins/numbers.kt:850:1")

    LBuiltin("rational", ::bi_rational,
            noStd,
            noKey,
            noOpt,
            /* rest */ "&rest",
            /* ret */ "nothing",
            /* special */ false,
            """
Function is not implemented; will throw an error.""",
            "builtins/numbers.kt:868:1")

    LBuiltin("rationalize", ::bi_rationalize,
            noStd,
            noKey,
            noOpt,
            /* rest */ "&rest",
            /* ret */ "nothing",
            /* special */ false,
            """
Function is not implemented; will throw an error.""",
            "builtins/numbers.kt:886:1")

    LBuiltin("minusp", ::bi_minusp,
            /* std */ arrayOf<String>("number"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return true iff `number` is less than zero.""",
            "builtins/numbers.kt:904:1")

    LBuiltin("plusp", ::bi_plusp,
            /* std */ arrayOf<String>("number"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return true iff `number` is greater than zero.""",
            "builtins/numbers.kt:922:1")

    LBuiltin("integer-length", ::bi_integer_length,
            /* std */ arrayOf<String>("integer"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "length",
            /* special */ false,
            """
Returns the number of bits needed to represent `integer`.
If the argument is not an integer, it will be rounded to the nearest one.""",
            "builtins/numbers.kt:941:1")

    LBuiltin("expt", ::bi_expt,
            /* std */ arrayOf<String>("base", "power"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "result",
            /* special */ false,
            """
Return `base` raise to the power `power`.""",
            "builtins/numbers.kt:970:1")

    LBuiltin("numerator", ::bi_numerator,
            /* std */ arrayOf<String>("number"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "number",
            /* special */ false,
            """
Return the numerator of `number`.
As only real numbers are supported, the numerator of a number is
always the number itself.""",
            "builtins/numbers.kt:992:1")

    LBuiltin("denominator", ::bi_denominator,
            /* std */ arrayOf<String>("number"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "number",
            /* special */ false,
            """
Return the denominator of `number`.
As only real numbers are supported, the denominator of a number is
always 1.""",
            "builtins/numbers.kt:1014:1")

    LBuiltin("realpart", ::bi_realpart,
            /* std */ arrayOf<String>("number"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "number",
            /* special */ false,
            """
Return the realpart of `number`.
As only real numbers are supported, the real part of a number is
always the number itself.""",
            "builtins/numbers.kt:1036:1")

    LBuiltin("imagpart", ::bi_imagpart,
            /* std */ arrayOf<String>("number"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "number",
            /* special */ false,
            """
Return the imagpart of `number`.
As only real numbers are supported, the imaginary part of a number is
always zero.""",
            "builtins/numbers.kt:1058:1")

    LBuiltin("phase", ::bi_phase,
            /* std */ arrayOf<String>("number"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "phase",
            /* special */ false,
            """
Return the angle part of `number`'s polar representation.
As only real numbers are supported, the return value is only -Pi for
negative numbers, Pi for positive numbers, and zero for zero.""",
            "builtins/numbers.kt:1080:1")

    LBuiltin("pi", ::bi_pi,
            noStd,
            noKey,
            noOpt,
            noRest,
            /* ret */ "pi",
            /* special */ false,
            """
Return the value of the constant Pi.""",
            "builtins/numbers.kt:1106:1")

    LBuiltin("e", ::bi_e,
            noStd,
            noKey,
            noOpt,
            noRest,
            /* ret */ "e",
            /* special */ false,
            """
Return the value of the constant E.""",
            "builtins/numbers.kt:1124:1")

    LBuiltin("fceiling", ::bi_fceiling,
            /* std */ arrayOf<String>("number"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "result",
            /* special */ false,
            """
Return `number` truncated to an integer towards positive infinity.""",
            "builtins/numbers.kt:1142:1")

    LBuiltin("log", ::bi_log,
            /* std */ arrayOf<String>("number"),
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("base", makeNumber(E)), ),
            noRest,
            /* ret */ "result",
            /* special */ false,
            """
Return the logarithm of `number` in base `base` (defaults to e).""",
            "builtins/numbers.kt:1160:1")

    LBuiltin("exp", ::bi_exp,
            /* std */ arrayOf<String>("power"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "result",
            /* special */ false,
            """
Return e raised to the power of `power`.""",
            "builtins/numbers.kt:1180:1")

    LBuiltin("tanh", ::bi_tanh,
            /* std */ arrayOf<String>("radians"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "result",
            /* special */ false,
            """
Return the hyperbolic tangent of `radians`""",
            "builtins/numbers.kt:1198:1")

    LBuiltin("cosh", ::bi_cosh,
            /* std */ arrayOf<String>("radians"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "result",
            /* special */ false,
            """
Return the hyperbolic cosine of `radians`""",
            "builtins/numbers.kt:1216:1")

    LBuiltin("sinh", ::bi_sinh,
            /* std */ arrayOf<String>("radians"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "result",
            /* special */ false,
            """
Return the hyperbolic sine of `radians`""",
            "builtins/numbers.kt:1234:1")

    LBuiltin("tan", ::bi_tan,
            /* std */ arrayOf<String>("radians"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "result",
            /* special */ false,
            """
Return the tangent of `radians`""",
            "builtins/numbers.kt:1252:1")

    LBuiltin("cos", ::bi_cos,
            /* std */ arrayOf<String>("radians"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "result",
            /* special */ false,
            """
Return the cosine of `radians`""",
            "builtins/numbers.kt:1270:1")

    LBuiltin("sin", ::bi_sin,
            /* std */ arrayOf<String>("radians"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "result",
            /* special */ false,
            """
Return the sine of `radians`""",
            "builtins/numbers.kt:1288:1")

    LBuiltin("truncate", ::bi_truncate,
            /* std */ arrayOf<String>("number"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "result",
            /* special */ false,
            """
Return `number` truncated towards zero.""",
            "builtins/numbers.kt:1306:1")

    LBuiltin("ftruncate", ::bi_truncate,
            /* std */ arrayOf<String>("number"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "result",
            /* special */ false,
            """
Return `number` truncated towards zero.""",
            "builtins/numbers.kt:1318:1")

    LBuiltin("random", ::bi_random,
            noStd,
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("limit", Nil), Pair("int", Nil), ),
            noRest,
            /* ret */ "random-number",
            /* special */ false,
            """
Return a non-negative pseudo-random number less than 1 (or `limit`).
If optional `int` is non-nil, the returned number is an integer.""",
            "builtins/numbers.kt:1337:1")

    LBuiltin("max", ::bi_max,
            /* std */ arrayOf<String>("number"),
            noKey,
            noOpt,
            /* rest */ "numbers",
            /* ret */ "maximum",
            /* special */ false,
            """
Return the largest number of all arguments""",
            "builtins/numbers.kt:1371:1")

    LBuiltin("min", ::bi_min,
            /* std */ arrayOf<String>("number"),
            noKey,
            noOpt,
            /* rest */ "numbers",
            /* ret */ "minimum",
            /* special */ false,
            """
Return the smallest number of all arguments""",
            "builtins/numbers.kt:1398:1")

    LBuiltin("rem", ::bi_rem,
            /* std */ arrayOf<String>("number", "divisor"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "remainder",
            /* special */ false,
            """
Return the remainder of the division of `number` by `divisor`.""",
            "builtins/numbers.kt:1425:1")

    LBuiltin("mod", ::bi_mod,
            /* std */ arrayOf<String>("number", "divisor"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "modulus",
            /* special */ false,
            """
Return the modulus of the division of `number` by `divisor`.""",
            "builtins/numbers.kt:1445:1")

    LBuiltin("div", ::bi_div_int,
            /* std */ arrayOf<String>("number", "divisor"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "number",
            /* special */ false,
            """
Return the result of the integer division of `number` by `divisor`.""",
            "builtins/numbers.kt:1465:1")

    LBuiltin("digit-char-p", ::bi_digit_char_p,
            /* std */ arrayOf<String>("char"),
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("radix", makeNumber(10)), ),
            noRest,
            /* ret */ "weight",
            /* special */ false,
            """
If `char` is a digit in the given `radix`, return its integer value, or nil.
The radix must be in the range 2..36.""",
            "builtins/numbers.kt:1525:1")

    LBuiltin("parse-integer", ::bi_parse_integer,
            /* std */ arrayOf<String>("string"),
            /* key */ mapOf<String, LObject>("start" to makeNumber(0), "end" to Nil, "radix" to Nil, "junk-allowed" to Nil),
            noOpt,
            noRest,
            /* ret */ "integer",
            /* special */ false,
            """
""",
            "builtins/numbers.kt:1560:1")

    LBuiltin("float", ::bi_float,
            /* std */ arrayOf<String>("number"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "number",
            /* special */ false,
            """
Return the argument as a float.
This is a null operation for a number (as all numbers are floats).
For any other argument type, this function raises an error.""",
            "builtins/numbers.kt:1623:1")

    LBuiltin("elt", ::bi_elt,
            /* std */ arrayOf<String>("sequence", "index"),
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("default", Nil), ),
            noRest,
            /* ret */ "element",
            /* special */ false,
            """
Return the value of `sequence` (list, vector) element at `index`.
Throw an error if the (zero-based) `index` is not in the sequence.""",
            "builtins/sequences.kt:20:1")

    LBuiltin("setelt", ::bi_setelt,
            /* std */ arrayOf<String>("sequence", "index", "value"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "element",
            /* special */ false,
            """
Set element `index` of sequence `sequence` to `value`; return `value`.
The index is zero-based. It is an error if `index` is negative or
greater than the length of the sequence.""",
            "builtins/sequences.kt:43:1")

    LBuiltin("elements", ::bi_elements,
            /* std */ arrayOf<String>("sequence"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "elements-list",
            /* special */ false,
            """
Return a list with all elements of `sequence`, in order.""",
            "builtins/sequences.kt:63:1")

    LBuiltin("copy-seq", ::bi_copy_seq,
            /* std */ arrayOf<String>("sequence"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "copied-sequence",
            /* special */ false,
            """
Return a copy of `sequence`.
The elements of the new sequence are the same as the corresponding
elements of the given sequence.""",
            "builtins/sequences.kt:87:1")

    LBuiltin("doseq", ::bi_doseq,
            /* std */ arrayOf<String>("control-vars"),
            noKey,
            noOpt,
            /* rest */ "bodyforms",
            /* ret */ "result",
            /* special */ true,
            """
Bind `var` to every element of `seq`, execute body and return the result.
`control-vars` is a list of (var seq [result-form [start [end]]]])""",
            "builtins/sequences.kt:106:1")

    LBuiltin("subseq", ::bi_subseq,
            /* std */ arrayOf<String>("sequence", "start"),
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("end", Nil), ),
            noRest,
            /* ret */ "subsequence",
            /* special */ false,
            """
Return a copy of the subsequence of `sequence` from `start` to `end`.
If `end` is omitted, the end of the sequence is assumed.""",
            "builtins/sequences.kt:146:1")

    LBuiltin("delete", ::bi_delete,
            /* std */ arrayOf<String>("item", "sequence"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "result-sequence",
            /* special */ false,
            """
Return a sequence from which the occurences of `item` have been removed.
The sequence may be modified.""",
            "builtins/sequences.kt:170:1")

    LBuiltin("find", ::bi_find,
            /* std */ arrayOf<String>("item", "sequence"),
            /* key */ mapOf<String, LObject>("from-end" to Nil, "test" to Nil, "test-not" to Nil, "start" to numberZero, "end" to Nil, "key" to Nil),
            noOpt,
            noRest,
            /* ret */ "element",
            /* special */ false,
            """
Return first `item` from `sequence` if it is in `sequence`, or nil.
If `from-end` is true, return the last `item` found instead.
If `test` is not nil, it is used as a function to check the equality
of the elements of the sequence with `item`. Per default, use `equal`.
If `test-not` is not nil, it is used as a function to check the
non-equality of the elements of the sequence with `item`.
Use `start` as the start index of the subsequence to search.
Use `end`, if non-nil, as the end index of the subsequence to search.
Use `key`, if non-nil, as a function applied to the elements of the
sequence before testing against the result.""",
            "builtins/sequences.kt:249:1")

    LBuiltin("position", ::bi_position,
            /* std */ arrayOf<String>("item", "sequence"),
            /* key */ mapOf<String, LObject>("from-end" to Nil, "test" to Nil, "test-not" to Nil, "start" to numberZero, "end" to Nil, "key" to Nil),
            noOpt,
            noRest,
            /* ret */ "element",
            /* special */ false,
            """
Return first index of `item` from `sequence` if it is in `sequence`, or nil.
If `from-end` is true, return the last `item` found instead.
If `test` is not nil, it is used as a function to check the equality
of the elements of the sequence with `item`. Per default, use `equal`.
If `test-not` is not nil, it is used as a function to check the
non-equality of the elements of the sequence with `item`.
Use `start` as the start index of the subsequence to search.
Use `end`, if non-nil, as the end index of the subsequence to search.
Use `key`, if non-nil, as a function applied to the elements of the
sequence before testing against the result.""",
            "builtins/sequences.kt:276:1")

    LBuiltin("find-if", ::bi_find_if,
            /* std */ arrayOf<String>("predicate", "sequence"),
            /* key */ mapOf<String, LObject>("from-end" to Nil, "start" to numberZero, "end" to Nil, "key" to Nil),
            noOpt,
            noRest,
            /* ret */ "element",
            /* special */ false,
            """
Return first element from `sequence` where `predicate` is true, or nil.
If `from-end` is true, return the last `item` found instead.
Use `start` as the start index of the subsequence to search.
Use `end`, if non-nil, as the end index of the subsequence to search.
Use `key`, if non-nil, as a function applied to the elements of the
sequence before testing against the result.""",
            "builtins/sequences.kt:325:1")

    LBuiltin("find-if-not", ::bi_find_if_not,
            /* std */ arrayOf<String>("predicate", "sequence"),
            /* key */ mapOf<String, LObject>("from-end" to Nil, "start" to numberZero, "end" to Nil, "key" to Nil),
            noOpt,
            noRest,
            /* ret */ "element",
            /* special */ false,
            """
Return first element from `sequence` where `predicate` is false, or nil.
If `from-end` is true, return the last `item` found instead.
Use `start` as the start index of the subsequence to search.
Use `end`, if non-nil, as the end index of the subsequence to search.
Use `key`, if non-nil, as a function applied to the elements of the
sequence before testing against the result.""",
            "builtins/sequences.kt:349:1")

    LBuiltin("position-if", ::bi_position_if,
            /* std */ arrayOf<String>("predicate", "sequence"),
            /* key */ mapOf<String, LObject>("from-end" to Nil, "start" to numberZero, "end" to Nil, "key" to Nil),
            noOpt,
            noRest,
            /* ret */ "element",
            /* special */ false,
            """
Return first element from `sequence` where `predicate` is true, or nil.
If `from-end` is true, return the last `item` found instead.
Use `start` as the start index of the subsequence to search.
Use `end`, if non-nil, as the end index of the subsequence to search.
Use `key`, if non-nil, as a function applied to the elements of the
sequence before testing against the result.""",
            "builtins/sequences.kt:379:1")

    LBuiltin("position-if-not", ::bi_position_if_not,
            /* std */ arrayOf<String>("predicate", "sequence"),
            /* key */ mapOf<String, LObject>("from-end" to Nil, "start" to numberZero, "end" to Nil, "key" to Nil),
            noOpt,
            noRest,
            /* ret */ "element",
            /* special */ false,
            """
Return first element from `sequence` where `predicate` is false, or nil.
If `from-end` is true, return the last `item` found instead.
Use `start` as the start index of the subsequence to search.
Use `end`, if non-nil, as the end index of the subsequence to search.
Use `key`, if non-nil, as a function applied to the elements of the
sequence before testing against the result.""",
            "builtins/sequences.kt:402:1")

    LBuiltin("string", ::bi_string,
            noStd,
            noKey,
            noOpt,
            /* rest */ "items",
            /* ret */ "string",
            /* special */ false,
            """
Make a string from all arguments and return it.""",
            "builtins/strings.kt:20:1")

    LBuiltin("make-string", ::bi_make_string,
            /* std */ arrayOf<String>("length"),
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("initial", makeString("\u0020")), ),
            noRest,
            /* ret */ "string",
            /* special */ false,
            """
Return a string of `length` with the contents taken from `initial`.""",
            "builtins/strings.kt:38:1")

    LBuiltin("join", ::bi_join,
            /* std */ arrayOf<String>("items"),
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("sep", defaultStringSep), ),
            noRest,
            /* ret */ "string",
            /* special */ false,
            """
Make a string from all `items` (a sequence), separated by `sep`
and return it.""",
            "builtins/strings.kt:82:1")

    LBuiltin("regexp", ::bi_regexp,
            /* std */ arrayOf<String>("pattern"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "regexp-object",
            /* special */ false,
            """
Return a new regexp object built from `pattern` (a kind of string).
See `regexp-match` for more information about regular expressions.""",
            "builtins/strings.kt:103:1")

    LBuiltin("regexp-match", ::bi_regexp_match,
            /* std */ arrayOf<String>("regexp", "string"),
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("limit", Nil), ),
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return a list of matches if regexp `regexp` matches `string`, nil else.
The returned value in case of a match is a list of the values for the
whole match and possible group matches. If an optional group (...)?
does not match, its value is "".
With optional third argument `limit`, a list of match lists for
(potentially) multiple matches is returned. If `limit` is t, all matches
are considered; otherwise, a number specifies the number of matches to
be considered.
Regular expression syntax is that of the Kotlin regexp package (RE2),
which is largely similar to that of the Perl and Python languages.
A \"(?flags)\" specification in the regexp can modify the behaviour
of the match in the current group. Possible flags are:

i  case-insensitive (default false)
m  multi-line mode: ^ and $ match begin/end line in addition to begin/end
   text (default false)
s  let . match \\n (default false)""",
            "builtins/strings.kt:142:1")

    LBuiltin("regexp-split", ::bi_regexp_split,
            /* std */ arrayOf<String>("re", "string"),
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("limit", makeNumber(0)), ),
            noRest,
            /* ret */ "string-list",
            /* special */ false,
            """
Split the string around regexp matches and return a list of the parts.
If `limit` is greater than (default) 0, only so many parts are split""",
            "builtins/strings.kt:184:1")

    LBuiltin("regexp-replace", ::bi_regexp_replace,
            /* std */ arrayOf<String>("re", "string", "replacement"),
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("limit", makeNumber(0)), ),
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t if regexp `re` replacees `string`, nil else.""",
            "builtins/strings.kt:204:1")

    LBuiltin("string-split", ::bi_string_split,
            /* std */ arrayOf<String>("string"),
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("separator", Nil), Pair("limit", Nil), Pair("keep-empty", Nil), ),
            noRest,
            /* ret */ "string-list",
            /* special */ false,
            """
Split `string` into parts separated by `separator`; return them as list.
If `separator` is a regexp object, a regexp match is done instead of a
string match. If it is nil or unspecified, it is assumed to be
whitespace. if `limit` is non-nil and positive, it is the maximum
number of parts into which the string is split.
If separator and keep-empty are both nil, don't keep empty parts at
the beginning or the end of the list.""",
            "builtins/strings.kt:231:1")

    LBuiltin("string-upcase", ::bi_string_upcase,
            /* std */ arrayOf<String>("string"),
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("start", Nil), Pair("end", Nil), ),
            noRest,
            /* ret */ "string",
            /* special */ false,
            """
Return `string` with all lowercase chars replaced by uppercase chars.
`start` and `end` may specify the region of the string to be treated;
defaults are 0 and the end of the string.""",
            "builtins/strings.kt:287:1")

    LBuiltin("string-downcase", ::bi_string_downcase,
            /* std */ arrayOf<String>("string"),
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("start", Nil), Pair("end", Nil), ),
            noRest,
            /* ret */ "string",
            /* special */ false,
            """
Return `string` with all lowercase chars replaced by uppercase chars.
`start` and `end` may specify the region of the string to be treated;
defaults are 0 and the end of the string.""",
            "builtins/strings.kt:325:1")

    LBuiltin("string-capitalize", ::bi_string_capitalize,
            /* std */ arrayOf<String>("string"),
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("start", Nil), Pair("end", Nil), ),
            noRest,
            /* ret */ "string",
            /* special */ false,
            """
Return `string` with all lowercase chars replaced by uppercase chars.
`start` and `end` may specify the region of the string to be treated;
defaults are 0 and the end of the string.""",
            "builtins/strings.kt:387:1")

    LBuiltin("string-trim", ::bi_string_trim,
            /* std */ arrayOf<String>("char-bag", "string"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "trimmed-string",
            /* special */ false,
            """
Return a substring of `string`, with characters in `char-bag` stripped
off the beginning and end. `char-bag` may be t, in which case all
whitespace characters will be stripped, or a sequence of characters.""",
            "builtins/strings.kt:460:1")

    LBuiltin("string-left-trim", ::bi_string_left_trim,
            /* std */ arrayOf<String>("char-bag", "string"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "trimmed-string",
            /* special */ false,
            """
Return a substring of `string`, with characters in `char-bag` stripped
off the beginning. `char-bag` may be t, in which case all whitespace
characters will be stripped, or a sequence of characters.""",
            "builtins/strings.kt:492:1")

    LBuiltin("string-right-trim", ::bi_string_right_trim,
            /* std */ arrayOf<String>("char-bag", "string"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "trimmed-string",
            /* special */ false,
            """
Return a substring of `string`, with characters in `char-bag` stripped
off the end. `char-bag` may be t, in which case all whitespace characters
will be stripped, or a sequence of characters.""",
            "builtins/strings.kt:521:1")

    LBuiltin("substring", ::bi_substring,
            /* std */ arrayOf<String>("string", "start"),
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("end", Nil), ),
            noRest,
            /* ret */ "string",
            /* special */ false,
            """
Return a substring of `string`, bounded by indices `start` and `end`
(or the end of the original string).""",
            "builtins/strings.kt:550:1")

    LBuiltin("string-contains-p", ::bi_string_contains_p,
            /* std */ arrayOf<String>("haystack", "needle"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t if string `haystack` contains `needle`.""",
            "builtins/strings.kt:583:1")

    LBuiltin("string-starts-with", ::bi_string_starts_with,
            /* std */ arrayOf<String>("string", "prefix"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return true iff `string` starts with `prefix`.""",
            "builtins/strings.kt:602:1")

    LBuiltin("string-ends-with", ::bi_string_ends_with,
            /* std */ arrayOf<String>("string", "prefix"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return true iff `string` ends with `prefix`.""",
            "builtins/strings.kt:621:1")

    LBuiltin("set-debug", ::bi_set_debug,
            noStd,
            noKey,
            noOpt,
            /* rest */ "symbols",
            /* ret */ "symbol-list",
            /* special */ false,
            """
Activate and deactivate debug topics (symbols), items/areas to be debugged.
Topics are activated by using their name as argument, or deactivated with
`-name`. To deactivate all, use `=off`. To show what topics are available,
use `=list`.
Return the active debug topics (a list of symbols) or all with `list`.""",
            "builtins/system.kt:29:1")

    LBuiltin("debug", ::bi_debug,
            /* std */ arrayOf<String>("topic"),
            noKey,
            noOpt,
            /* rest */ "data",
            /* ret */ "t/nil",
            /* special */ true,
            """
Print a debug message, if `topic` (a symbol, not evaluated) is enabled.
If the topic is enabled, evaluate all other arguments and print a debug
message from all of the value.
Return t if the topic is enabled; nil otherwise.""",
            "builtins/system.kt:89:1")

    LBuiltin("doc", ::bi_doc,
            /* std */ arrayOf<String>("symbol-or-function"),
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("return-as-string", Nil), Pair("synopsis-only", Nil), ),
            noRest,
            /* ret */ "object",
            /* special */ false,
            """
Return or print the documentation for `arg`, if available.
If optional `return-as-string` is true, return the docstring as a string,
otherwise print it and return `*the-non-printing-object*`.
If optional `synopsis-only` is true, print or return the function's
synopsis only.""",
            "builtins/system.kt:121:1")

    LBuiltin("numbers", ::bi_numbers,
            noStd,
            noKey,
            noOpt,
            noRest,
            /* ret */ "number-list",
            /* special */ false,
            """
Return a list of all number objects currently in use.""",
            "builtins/system.kt:160:1")

    LBuiltin("do-symbols", ::bi_do_symbols,
            /* std */ arrayOf<String>("control-vars"),
            noKey,
            noOpt,
            /* rest */ "bodyforms",
            /* ret */ "result",
            /* special */ true,
            """
(do-symbols (var [result-form]) bodyforms...)
Iterate over all symbols, bind them to `var`, and execute `bodyforms`.
If `result-form` is specified, evaluate and return it afterwards.""",
            "builtins/system.kt:181:1")

    LBuiltin("gc", ::bi_gc,
            noStd,
            noKey,
            noOpt,
            noRest,
            /* ret */ "nil",
            /* special */ false,
            """
Trigger a garbage collection.""",
            "builtins/system.kt:207:1")

    LBuiltin("assert", ::bi_assert,
            /* std */ arrayOf<String>("test-form"),
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("message", Nil), ),
            noRest,
            /* ret */ "nil",
            /* special */ true,
            """
Evaluate `test-form`, and if the result is nil, raise an error.
The error message includes `test-form`, and, if present, `message`
(which is evaluated in that case).""",
            "builtins/system.kt:228:1")

    LBuiltin("apropos", ::bi_apropos,
            /* std */ arrayOf<String>("pattern"),
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("as-list", Nil), ),
            noRest,
            /* ret */ "none/list",
            /* special */ false,
            """
Print all interned symbols whose name contains `pattern`.
`pattern` may be a string or a regular expression.
If optional `as-list` is true, return a list of the symbol names.""",
            "builtins/system.kt:253:1")

    LBuiltin("build-info", ::bi_build_info,
            noStd,
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("as-string", Nil), ),
            noRest,
            /* ret */ "alist",
            /* special */ false,
            """
Return an alist with data decribing the current program build.
If optional argument `as-string` is true, return the info as a string.""",
            "builtins/system.kt:328:1")

    LBuiltin("describe", ::bi_describe,
            /* std */ arrayOf<String>("object"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "description-list",
            /* special */ false,
            """
Describe `object` -- return a alist with the object's attributes.""",
            "builtins/system.kt:354:1")

    LBuiltin("provide", ::bi_provide,
            /* std */ arrayOf<String>("feature"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "feature",
            /* special */ false,
            """
Declare `feature` (a symbol) as provided in case it will be required.""",
            "builtins/system.kt:443:1")

    LBuiltin("require", ::bi_require,
            /* std */ arrayOf<String>("feature"),
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("filename", Nil), ),
            noRest,
            /* ret */ "t",
            /* special */ false,
            """
If `feature` (a symbol) is not already provided, load it from `filename`
(default: name of the feature). If the feature is still not provided,
throw an error.""",
            "builtins/system.kt:465:1")

    LBuiltin("barams", ::bi_barams,
            /* std */ arrayOf<String>("a", "b", "c"),
            /* key */ mapOf<String, LObject>("k1" to makeNumber(3), "k2" to Nil),
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("d", Nil), Pair("e", makeNumber(4)), ),
            /* rest */ "grabbelsack",
            /* ret */ "t",
            /* special */ false,
            """
Exercise all kinds of function parameters and return t.""",
            "builtins/system.kt:496:1")

    LBuiltin("exit", ::bi_exit,
            noStd,
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("exit-status", makeNumber(0)), ),
            noRest,
            /* ret */ "none",
            /* special */ false,
            """
End the lisp interpreted with (optional) exit status.""",
            "builtins/system.kt:530:1")

    LBuiltin("getenv", ::bi_getenv,
            /* std */ arrayOf<String>("variable"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "string-value",
            /* special */ false,
            """
Return the value of `variable` in the process environment.
If it is not defined, return an empty string.""",
            "builtins/system.kt:551:1")

    LBuiltin("process-env", ::bi_process_env,
            noStd,
            noKey,
            noOpt,
            noRest,
            /* ret */ "table",
            /* special */ false,
            """
Return a table with all process environment variables and their values.""",
            "builtins/system.kt:569:1")

    LBuiltin("env-table", ::bi_env_table,
            noStd,
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("environment", Nil), ),
            noRest,
            /* ret */ "table",
            /* special */ false,
            """
Return a table with all variables and values in the current environment.
Optionally, specify an environment.""",
            "builtins/system.kt:593:1")

    LBuiltin("env-vars", ::bi_env_vars,
            noStd,
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("environment", Nil), ),
            noRest,
            /* ret */ "var-list",
            /* special */ false,
            """
Return a list with all variables in the current environment.
Optionally, specify an environment.""",
            "builtins/system.kt:623:1")

    LBuiltin("function-definition", ::bi_function_definition,
            /* std */ arrayOf<String>("function"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "function-definition-form",
            /* special */ false,
            """
Return `function`'s definition form.
`function` must be a lambda function or a macro, not a builtin.
The function definition returned contains the real function body,
not a copy.""",
            "builtins/system.kt:651:1")

    LBuiltin("function-docstring", ::bi_function_docstring,
            /* std */ arrayOf<String>("function"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "docstring",
            /* special */ false,
            """
Return `function`'s docstring.""",
            "builtins/system.kt:669:1")

    LBuiltin("function-parameters", ::bi_function_parameters,
            /* std */ arrayOf<String>("function"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "parameter-list",
            /* special */ false,
            """
Return the parameter list of `function`.
The returned list is a reconstruction of the original parameter list;
modifying it will not change the function's behaviour.""",
            "builtins/system.kt:689:1")

    LBuiltin("make-symbol", ::bi_make_symbol,
            /* std */ arrayOf<String>("name"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "symbol",
            /* special */ false,
            """
Create and return a fresh, uninterned symbol whose name is `name`.
The new symbol is neither bound nor fbound and has a null property list.""",
            "builtins/system.kt:709:1")

    LBuiltin("symbol-value", ::bi_symbol_value,
            /* std */ arrayOf<String>("symbol"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return the value of `symbol`.""",
            "builtins/system.kt:728:1")

    LBuiltin("collect-performance-data", ::bi_collect_perfdata,
            noStd,
            noKey,
            noOpt,
            /* rest */ "bodyforms",
            /* ret */ "alist",
            /* special */ true,
            """
Evaluate `bodyforms` and return a list of performance data.
This list is an alist with the number of conses created, the number
of evals performed, and the number of seconds taken to perform the
evaluation, e.g.
    ((conses . 6055097) (evals . 4755187) (secs . 0.265043))""",
            "builtins/system.kt:751:1")

    LBuiltin("measure-time", ::bi_measure_time,
            noStd,
            noKey,
            noOpt,
            /* rest */ "bodyforms",
            /* ret */ "duration",
            /* special */ true,
            """
Run bodyforms and return the elapsed time in seconds.""",
            "builtins/system.kt:777:1")

    LBuiltin("no-warnings", ::bi_no_warnings,
            noStd,
            noKey,
            noOpt,
            /* rest */ "bodyforms",
            /* ret */ "result",
            /* special */ true,
            """
Eval bodyforms and return the result while suppressing warnings
(and other info/notice messages). If *warnings-as-errors* is true,
the error is raised nevertheless.""",
            "builtins/system.kt:801:1")

    LBuiltin("warnings-as-errors", ::bi_warnings_as_errors,
            noStd,
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("on", Nil), ),
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t if warnings as handled as errors, nil otherwise.
With optional `on` argument, set warnings to be handled as errors iff
`on` is true. In this case, return the status from *before* setting it.""",
            "builtins/system.kt:830:1")

    LBuiltin("run-program", ::bi_run_program,
            /* std */ arrayOf<String>("command"),
            /* key */ mapOf<String, LObject>("in-shell" to Nil, "input" to Nil, "output" to T, "error-output" to T, "env" to Nil, "raise-error" to Nil),
            noOpt,
            noRest,
            /* ret */ "exit-status",
            /* special */ false,
            """
Run an external command and return its exit status. If command  is a
list of strings, run it directly. Otherwise, if it is a single string:
  - if &key `in-shell` is t, run command as a shell command line with
    `/bin/sh`.
  - if &key `in-shell` is a string, use it as the shell and run the
    command in it, using the "-c" option like for `/bin/sh`.
  - if &key `in-shell` is nil (the default), run command with `/bin/sh`
    if it contains shell meta characters (~"'`|&,;[{(<>)}]*?$).
    Otherwise, split the string on whitespace and run it directly.
If &key `input` is a string or a stream, use it as the standard input
stream of the command. If it is t, the command reads from the normal
standard input; if it is nil, redirect it from the null device.
If &key `output` is a stream, use it as the standard output stream
of the command. You can use `make-string-output-stream` (with
`get-output-stream-string`) to capture the output of the command in the
program. The same goes for `error-output` and the standard error output.
If `output` is t, use the standard output; if it is nil, redirect the
command's output to the null device. The same goes for `error-output`.
If &key `env` (a table) is non-nil, use it as the process environment of
the command. Otherwise, use the default process environment.
If &key `raise-error` is true, raise an error if the command returns a
non-zero exit status.""",
            "builtins/system.kt:897:1")

    LBuiltin("error-object-p", ::bi_error_object_p,
            /* std */ arrayOf<String>("object"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t iff `object` is an error object, nil else.""",
            "builtins/system.kt:1063:1")

    LBuiltin("sleep", ::bi_sleep,
            /* std */ arrayOf<String>("seconds"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "nil",
            /* special */ false,
            """
Suspend execution for approximately the number of `seconds` and return.""",
            "builtins/system.kt:1081:1")

    LBuiltin("return", ::bi_return,
            noStd,
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("value", Nil), ),
            noRest,
            /* ret */ "none",
            /* special */ false,
            """
Return from the innermost function with `value` (defaults to nil).""",
            "builtins/system.kt:1104:1")

    LBuiltin("user-name", ::bi_user_name,
            noStd,
            noKey,
            noOpt,
            noRest,
            /* ret */ "string",
            /* special */ false,
            """
Return the username of the current user.""",
            "builtins/system.kt:1122:1")

    LBuiltin("load-preload-code", ::bi_load_preload_code,
            noStd,
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("verbose", Nil), ),
            noRest,
            /* ret */ "object",
            /* special */ false,
            """
Load the preload code.
This makes only sense if it hasn't been loaded before.""",
            "builtins/system.kt:1141:1")

    LBuiltin("system-time", ::bi_system_time,
            noStd,
            noKey,
            noOpt,
            noRest,
            /* ret */ "milliseconds",
            /* special */ false,
            """
Return the current system time in milliseconds.
This is the number of milliseconds since the beginning of the Unix
epoch, in theory. It may not be a good source for determining the
current calendar time.""",
            "builtins/system.kt:1164:1")

    LBuiltin("system-running-time", ::bi_system_running_time,
            noStd,
            noKey,
            noOpt,
            noRest,
            /* ret */ "milliseconds",
            /* special */ false,
            """
Return the number of milliseconds since the lyk system started.""",
            "builtins/system.kt:1182:1")

    LBuiltin("system-started-time", ::bi_system_started_time,
            noStd,
            noKey,
            noOpt,
            noRest,
            /* ret */ "milliseconds",
            /* special */ false,
            """
Return the number of milliseconds since the lyk system started.""",
            "builtins/system.kt:1200:1")

    LBuiltin("system-perfdata", ::bi_system_perfdata,
            noStd,
            noKey,
            noOpt,
            noRest,
            /* ret */ "result",
            /* special */ false,
            """
Return the overall system performance data as an alist.
The items in the returned list are, in this order:
  `call`: the number of function calls
  `cons`: the number of conses created
  `eval`: the number of evalulations done
  `secs`: the number of seconds elapsed since the start of lyk""",
            "builtins/system.kt:1223:1")

    LBuiltin("get-hooks", ::bi_get_hooks,
            noStd,
            noKey,
            noOpt,
            noRest,
            /* ret */ "alist",
            /* special */ false,
            """
Return an alist with (hooksym . function-list) pairs for all defined hooks.""",
            "builtins/system.kt:1245:1")

    LBuiltin("define-hook", ::bi_define_hook,
            /* std */ arrayOf<String>("hook-symbol"),
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("function", Nil), ),
            noRest,
            /* ret */ "hook-symbol",
            /* special */ false,
            """
Define a hook `hook-symbol` for later use.""",
            "builtins/system.kt:1267:1")

    LBuiltin("add-hook-function", ::bi_add_hook_function,
            /* std */ arrayOf<String>("hook-symbol", "function"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "nil",
            /* special */ false,
            """
Associate `function` with the `hook-symbol`, to be called when
the hook is activated.""",
            "builtins/system.kt:1288:1")

    LBuiltin("remove-hook-function", ::bi_remove_hook_function,
            /* std */ arrayOf<String>("hook-symbol", "function"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Remove `function` with the `hook-symbol`, so it os no longer
called when the hook is activated. Return t if the function was
in the hook functions.""",
            "builtins/system.kt:1311:1")

    LBuiltin("get-hook-functions", ::bi_get_hook_function,
            /* std */ arrayOf<String>("hook-symbol"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "function-list",
            /* special */ false,
            """
Return the function of hook `hook-symbol` (may be nil).""",
            "builtins/system.kt:1331:1")

    LBuiltin("run-hook-functions", ::bi_run_hook_functions,
            /* std */ arrayOf<String>("hook-symbol"),
            noKey,
            noOpt,
            /* rest */ "args",
            /* ret */ "t/nil",
            /* special */ false,
            """
Run the hook function of hook `hook-symbol` and return its value.
The `args` are passed to the function.""",
            "builtins/system.kt:1350:1")

    LBuiltin("lyk-command-options", ::bi_lyk_command_options,
            noStd,
            noKey,
            noOpt,
            noRest,
            /* ret */ "alist",
            /* special */ false,
            """
Return a alist of lyk's command line options and their values.
The debug options will not be shown; use `(set-debug)` for those.""",
            "builtins/system.kt:1370:1")

    LBuiltin("table-get", ::bi_table_get,
            /* std */ arrayOf<String>("table", "key"),
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("default", Nil), ),
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Return value associated in `table` with `key`.
If `key` is not present, return `default` (which defaults to nil).""",
            "builtins/tables.kt:18:1")

    LBuiltin("table-put", ::bi_table_put,
            /* std */ arrayOf<String>("table", "key", "value"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Make `table` associate `key` with `value`, return `value`.""",
            "builtins/tables.kt:38:1")

    LBuiltin("make-table", ::bi_make_table,
            noStd,
            noKey,
            noOpt,
            /* rest */ "pairs",
            /* ret */ "table",
            /* special */ false,
            """
Return a new table, optionally filled with `pairs`.
Every argument that is not a pair will be used as (arg . nil).""",
            "builtins/tables.kt:60:1")

    LBuiltin("table-count", ::bi_table_count,
            /* std */ arrayOf<String>("table"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "count",
            /* special */ false,
            """
Return the number of key-value pairs in `table`.""",
            "builtins/tables.kt:78:1")

    LBuiltin("table-exists", ::bi_table_exists,
            /* std */ arrayOf<String>("table", "key"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "t/nil",
            /* special */ false,
            """
Return t if `key` exists in `table`, nil else.""",
            "builtins/tables.kt:97:1")

    LBuiltin("table-inc", ::bi_table_inc,
            /* std */ arrayOf<String>("table", "key"),
            /* key */ mapOf<String, LObject>("create" to Nil, "initial" to makeNumber(0)),
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("increment", makeNumber(1)), ),
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Increment (and return) the numeric value for `key` in `table` by `increment`.
If keyword argument `create` is non-nil and `key` does not exist in table,
create the key with the value `initial` before incrementing. Otherwise, it
is an error if `key` does not exists in `table`.""",
            "builtins/tables.kt:122:1")

    LBuiltin("table-keys", ::bi_table_keys,
            /* std */ arrayOf<String>("table"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "keys",
            /* special */ false,
            """
Return a list of all keys in `table`.""",
            "builtins/tables.kt:159:1")

    LBuiltin("table-values", ::bi_table_values,
            /* std */ arrayOf<String>("table"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "values",
            /* special */ false,
            """
Return a list with all values in `table`.""",
            "builtins/tables.kt:178:1")

    LBuiltin("table-pairs", ::bi_table_pairs,
            /* std */ arrayOf<String>("table"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "pairs",
            /* special */ false,
            """
Return a list with all (key . value) pairs in `table`.""",
            "builtins/tables.kt:196:1")

    LBuiltin("table-remove", ::bi_table_remove,
            /* std */ arrayOf<String>("table", "key"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "table",
            /* special */ false,
            """
Remove `key` from `table` and return `table`.""",
            "builtins/tables.kt:215:1")

    LBuiltin("list-collector", ::bi_list_collector,
            noStd,
            noKey,
            noOpt,
            noRest,
            /* ret */ "closure",
            /* special */ false,
            """
Create a list collector closure and return it as a function.

The returned function takes an arbitrary number of arguments, which
are then added to the end of the list, and returns the list. The
normal use case would be to call it a number of times to add items to
the list, and then call it once without arguments to return the
resulting list. This is more efficient than using append repeatedly.

Example:
    (let ((lc (list-collector)))
      (lc 'see)
      (lc 0 'evil)
      (lc 'hear \"no\" 'evil)
      (lc))
    => (see 0 evil hear \"no\" evil)""",
            "builtins/utils.kt:30:1")

    LBuiltin("aref", ::bi_aref,
            /* std */ arrayOf<String>("vector", "index"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "element",
            /* special */ false,
            """
Return the element of `vector` at `index`.""",
            "builtins/vectors.kt:17:1")

    LBuiltin("vector-get", ::bi_aref,
            /* std */ arrayOf<String>("vector", "index"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "element",
            /* special */ false,
            """
Return the element of `vector` at `index`.""",
            "builtins/vectors.kt:29:1")

    LBuiltin("make-vector", ::bi_make_vector,
            /* std */ arrayOf<String>("length"),
            noKey,
            /* opt */ arrayOf<Pair<String, LObject>>(Pair("initial", Nil), ),
            noRest,
            /* ret */ "vector",
            /* special */ false,
            """
Return a new vector of length `length` and each element set to `initial`.""",
            "builtins/vectors.kt:49:1")

    LBuiltin("vector-set", ::bi_vector_set,
            /* std */ arrayOf<String>("vector", "index", "value"),
            noKey,
            noOpt,
            noRest,
            /* ret */ "value",
            /* special */ false,
            """
Set the element of `vector` at `index` to `value`; return `value`.""",
            "builtins/vectors.kt:80:1")

    LBuiltin("vector", ::bi_vector,
            noStd,
            noKey,
            noOpt,
            /* rest */ "elements",
            /* ret */ "vector",
            /* special */ false,
            """
""",
            "builtins/vectors.kt:101:1")

}
// EOF

